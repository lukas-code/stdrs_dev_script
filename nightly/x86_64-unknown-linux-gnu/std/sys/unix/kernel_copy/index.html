<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains specializations that can offload `io::copy()` operations on file descriptor containing types (`File`, `TcpStream`, etc.) to more efficient syscalls than `read(2)` and `write(2)`."><title>std::sys::unix::kernel_copy - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (b2b34bd83 2023-06-06)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../../static.files/main-48600a9606eff342.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"><script src="/nav.js"></script>
</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module kernel_copy</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">std</a>::<wbr><a href="../../index.html">sys</a>::<wbr><a href="../index.html">unix</a>::<wbr><a class="mod" href="#">kernel_copy</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../../src/std/sys/unix/kernel_copy.rs.html#1-720">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains specializations that can offload <code>io::copy()</code> operations on file descriptor
containing types (<code>File</code>, <code>TcpStream</code>, etc.) to more efficient syscalls than <code>read(2)</code> and <code>write(2)</code>.</p>
<p>Specialization is only applied to wholly std-owned types so that user code canâ€™t observe
that the <code>Read</code> and <code>Write</code> traits are not used.</p>
<p>Since a copy operation involves a reader and writer side where each can consist of different types
and also involve generic wrappers (e.g. <code>Take</code>, <code>BufReader</code>) it is not practical to specialize
a single method on all possible combinations.</p>
<p>Instead readers and writers are handled separately by the <code>CopyRead</code> and <code>CopyWrite</code> specialization
traits and then specialized on by the <code>Copier::copy</code> method.</p>
<p><code>Copier</code> uses the specialization traits to unpack the underlying file descriptors and
additional prerequisites and constraints imposed by the wrapper types.</p>
<p>Once it has obtained all necessary pieces and brought any wrapper types into a state where they
can be safely bypassed it will attempt to use the <code>copy_file_range(2)</code>,
<code>sendfile(2)</code> or <code>splice(2)</code> syscalls to move data directly between file descriptors.
Since those syscalls have requirements that cannot be fully checked in advance it attempts
to use them one after another (guided by hints) to figure out which one works and
falls back to the generic read-write copy loop if none of them does.
Once a working syscall is found for a pair of file descriptors it will be called in a loop
until the copy operation is completed.</p>
<p>Advantages of using these syscalls:</p>
<ul>
<li>fewer context switches since reads and writes are coalesced into a single syscall
and more bytes are transferred per syscall. This translates to higher throughput
and fewer CPU cycles, at least for sufficiently large transfers to amortize the initial probing.</li>
<li><code>copy_file_range</code> creates reflink copies on CoW filesystems, thus moving less data and
consuming less disk space</li>
<li><code>sendfile</code> and <code>splice</code> can perform zero-copy IO under some circumstances while
a naive copy loop would move every byte through the CPU.</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li>copy operations smaller than the default buffer size can under some circumstances, especially
on older kernels, incur more syscalls than the naive approach would. As mentioned above
the syscall selection is guided by hints to minimize this possibility but they are not perfect.</li>
<li>optimizations only apply to std types. If a user adds a custom wrapper type, e.g. to report
progress, they can hit a performance cliff.</li>
<li>complexity</li>
</ul>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Copier.html" title="struct std::sys::unix::kernel_copy::Copier">Copier</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.CopyParams.html" title="struct std::sys::unix::kernel_copy::CopyParams">CopyParams</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CopyResult.html" title="enum std::sys::unix::kernel_copy::CopyResult">CopyResult</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="enum" href="enum.FdMeta.html" title="enum std::sys::unix::kernel_copy::FdMeta">FdMeta</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">This type represents either the inferred <code>FileType</code> of a <code>RawFd</code> based on the source
type from which it was extracted or the actual metadata</div></li><li><div class="item-name"><a class="enum" href="enum.SpliceMode.html" title="enum std::sys::unix::kernel_copy::SpliceMode">SpliceMode</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.INVALID_FD.html" title="constant std::sys::unix::kernel_copy::INVALID_FD">INVALID_FD</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Invalid file descriptor.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.CopyRead.html" title="trait std::sys::unix::kernel_copy::CopyRead">CopyRead</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="trait" href="trait.CopyWrite.html" title="trait std::sys::unix::kernel_copy::CopyWrite">CopyWrite</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="trait" href="trait.SpecCopy.html" title="trait std::sys::unix::kernel_copy::SpecCopy">SpecCopy</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.copy_regular_files.html" title="fn std::sys::unix::kernel_copy::copy_regular_files">copy_regular_files</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Linux-specific implementation that will attempt to use copy_file_range for copy offloading.
As the name says, it only works on regular files.</div></li><li><div class="item-name"><a class="fn" href="fn.copy_spec.html" title="fn std::sys::unix::kernel_copy::copy_spec">copy_spec</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.fd_to_meta.html" title="fn std::sys::unix::kernel_copy::fd_to_meta">fd_to_meta</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.safe_kernel_copy.html" title="fn std::sys::unix::kernel_copy::safe_kernel_copy">safe_kernel_copy</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Returns true either if changes made to the source after a sendfile/splice call wonâ€™t become
visible in the sink or the source has explicitly opted into such behavior (e.g. by splicing
a file into a pipe, the pipe being the source in this case).</div></li><li><div class="item-name"><a class="fn" href="fn.sendfile_splice.html" title="fn std::sys::unix::kernel_copy::sendfile_splice">sendfile_splice</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">performs splice or sendfile between file descriptors
Does <em>not</em> fall back to a generic copy loop.</div></li></ul></section></div></main></body></html>