<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `avx512f` mod in crate `core`."><title>core::core_arch::x86::avx512f - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (b2b34bd83 2023-06-06)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../../static.files/main-48600a9606eff342.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"><script src="/stdrs_dev_script/nav.js"></script>
</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../core/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../core/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module avx512f</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">core</a>::<wbr><a href="../../index.html">core_arch</a>::<wbr><a href="../index.html">x86</a>::<wbr><a class="mod" href="#">avx512f</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../../src/core/stdarch/crates/core_arch/src/x86/avx512f.rs.html#1-55860">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>stdsimd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/48556">#48556</a>)</span></div><div class="stab portability">Available on <strong>x86 or x86-64</strong> only.</div></span><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.vpl.html" title="macro core::core_arch::x86::avx512f::vpl">vpl</a><span title="Restricted Visibility">&nbsp;🔒</span> <span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="macro" href="macro.vps.html" title="macro core::core_arch::x86::avx512f::vps">vps</a><span title="Restricted Visibility">&nbsp;🔒</span> <span class="stab unstable" title="">Experimental</span></div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_EQ.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_EQ">_MM_CMPINT_EQ</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_FALSE.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_FALSE">_MM_CMPINT_FALSE</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">False</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_LE.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_LE">_MM_CMPINT_LE</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Less-than-or-equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_LT.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_LT">_MM_CMPINT_LT</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Less-than</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NE.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_NE">_MM_CMPINT_NE</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Not-equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NLE.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_NLE">_MM_CMPINT_NLE</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Not less-than-or-equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NLT.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_NLT">_MM_CMPINT_NLT</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Not less-than</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_TRUE.html" title="constant core::core_arch::x86::avx512f::_MM_CMPINT_TRUE">_MM_CMPINT_TRUE</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">True</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_1_2.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_NORM_1_2">_MM_MANT_NORM_1_2</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">interval [1, 2)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P5_1.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_NORM_P5_1">_MM_MANT_NORM_P5_1</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">interval [0.5, 1)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P5_2.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_NORM_P5_2">_MM_MANT_NORM_P5_2</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">interval [0.5, 2)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P75_1P5.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_NORM_P75_1P5">_MM_MANT_NORM_P75_1P5</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">interval [0.75, 1.5)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_NAN.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_SIGN_NAN">_MM_MANT_SIGN_NAN</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">DEST = NaN if sign(SRC) = 1</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_SRC.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_SIGN_SRC">_MM_MANT_SIGN_SRC</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">sign = sign(SRC)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_ZERO.html" title="constant core::core_arch::x86::avx512f::_MM_MANT_SIGN_ZERO">_MM_MANT_SIGN_ZERO</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">sign = 0</div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AAAA">_MM_PERM_AAAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AAAB">_MM_PERM_AAAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AAAC">_MM_PERM_AAAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AAAD">_MM_PERM_AAAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AABA">_MM_PERM_AABA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AABB">_MM_PERM_AABB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AABC">_MM_PERM_AABC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AABD">_MM_PERM_AABD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AACA">_MM_PERM_AACA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AACB">_MM_PERM_AACB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AACC">_MM_PERM_AACC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AACD">_MM_PERM_AACD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AADA">_MM_PERM_AADA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AADB">_MM_PERM_AADB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AADC">_MM_PERM_AADC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_AADD">_MM_PERM_AADD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABAA">_MM_PERM_ABAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABAB">_MM_PERM_ABAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABAC">_MM_PERM_ABAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABAD">_MM_PERM_ABAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABBA">_MM_PERM_ABBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABBB">_MM_PERM_ABBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABBC">_MM_PERM_ABBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABBD">_MM_PERM_ABBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABCA">_MM_PERM_ABCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABCB">_MM_PERM_ABCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABCC">_MM_PERM_ABCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABCD">_MM_PERM_ABCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABDA">_MM_PERM_ABDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABDB">_MM_PERM_ABDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABDC">_MM_PERM_ABDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ABDD">_MM_PERM_ABDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACAA">_MM_PERM_ACAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACAB">_MM_PERM_ACAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACAC">_MM_PERM_ACAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACAD">_MM_PERM_ACAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACBA">_MM_PERM_ACBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACBB">_MM_PERM_ACBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACBC">_MM_PERM_ACBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACBD">_MM_PERM_ACBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACCA">_MM_PERM_ACCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACCB">_MM_PERM_ACCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACCC">_MM_PERM_ACCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACCD">_MM_PERM_ACCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACDA">_MM_PERM_ACDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACDB">_MM_PERM_ACDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACDC">_MM_PERM_ACDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ACDD">_MM_PERM_ACDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADAA">_MM_PERM_ADAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADAB">_MM_PERM_ADAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADAC">_MM_PERM_ADAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADAD">_MM_PERM_ADAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADBA">_MM_PERM_ADBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADBB">_MM_PERM_ADBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADBC">_MM_PERM_ADBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADBD">_MM_PERM_ADBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADCA">_MM_PERM_ADCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADCB">_MM_PERM_ADCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADCC">_MM_PERM_ADCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADCD">_MM_PERM_ADCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADDA">_MM_PERM_ADDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADDB">_MM_PERM_ADDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADDC">_MM_PERM_ADDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_ADDD">_MM_PERM_ADDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BAAA">_MM_PERM_BAAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BAAB">_MM_PERM_BAAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BAAC">_MM_PERM_BAAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BAAD">_MM_PERM_BAAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BABA">_MM_PERM_BABA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BABB">_MM_PERM_BABB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BABC">_MM_PERM_BABC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BABD">_MM_PERM_BABD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BACA">_MM_PERM_BACA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BACB">_MM_PERM_BACB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BACC">_MM_PERM_BACC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BACD">_MM_PERM_BACD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BADA">_MM_PERM_BADA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BADB">_MM_PERM_BADB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BADC">_MM_PERM_BADC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BADD">_MM_PERM_BADD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBAA">_MM_PERM_BBAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBAB">_MM_PERM_BBAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBAC">_MM_PERM_BBAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBAD">_MM_PERM_BBAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBBA">_MM_PERM_BBBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBBB">_MM_PERM_BBBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBBC">_MM_PERM_BBBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBBD">_MM_PERM_BBBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBCA">_MM_PERM_BBCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBCB">_MM_PERM_BBCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBCC">_MM_PERM_BBCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBCD">_MM_PERM_BBCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBDA">_MM_PERM_BBDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBDB">_MM_PERM_BBDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBDC">_MM_PERM_BBDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BBDD">_MM_PERM_BBDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCAA">_MM_PERM_BCAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCAB">_MM_PERM_BCAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCAC">_MM_PERM_BCAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCAD">_MM_PERM_BCAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCBA">_MM_PERM_BCBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCBB">_MM_PERM_BCBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCBC">_MM_PERM_BCBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCBD">_MM_PERM_BCBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCCA">_MM_PERM_BCCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCCB">_MM_PERM_BCCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCCC">_MM_PERM_BCCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCCD">_MM_PERM_BCCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCDA">_MM_PERM_BCDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCDB">_MM_PERM_BCDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCDC">_MM_PERM_BCDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BCDD">_MM_PERM_BCDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDAA">_MM_PERM_BDAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDAB">_MM_PERM_BDAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDAC">_MM_PERM_BDAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDAD">_MM_PERM_BDAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDBA">_MM_PERM_BDBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDBB">_MM_PERM_BDBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDBC">_MM_PERM_BDBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDBD">_MM_PERM_BDBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDCA">_MM_PERM_BDCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDCB">_MM_PERM_BDCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDCC">_MM_PERM_BDCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDCD">_MM_PERM_BDCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDDA">_MM_PERM_BDDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDDB">_MM_PERM_BDDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDDC">_MM_PERM_BDDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_BDDD">_MM_PERM_BDDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CAAA">_MM_PERM_CAAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CAAB">_MM_PERM_CAAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CAAC">_MM_PERM_CAAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CAAD">_MM_PERM_CAAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CABA">_MM_PERM_CABA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CABB">_MM_PERM_CABB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CABC">_MM_PERM_CABC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CABD">_MM_PERM_CABD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CACA">_MM_PERM_CACA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CACB">_MM_PERM_CACB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CACC">_MM_PERM_CACC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CACD">_MM_PERM_CACD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CADA">_MM_PERM_CADA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CADB">_MM_PERM_CADB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CADC">_MM_PERM_CADC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CADD">_MM_PERM_CADD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBAA">_MM_PERM_CBAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBAB">_MM_PERM_CBAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBAC">_MM_PERM_CBAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBAD">_MM_PERM_CBAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBBA">_MM_PERM_CBBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBBB">_MM_PERM_CBBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBBC">_MM_PERM_CBBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBBD">_MM_PERM_CBBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBCA">_MM_PERM_CBCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBCB">_MM_PERM_CBCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBCC">_MM_PERM_CBCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBCD">_MM_PERM_CBCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBDA">_MM_PERM_CBDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBDB">_MM_PERM_CBDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBDC">_MM_PERM_CBDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CBDD">_MM_PERM_CBDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCAA">_MM_PERM_CCAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCAB">_MM_PERM_CCAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCAC">_MM_PERM_CCAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCAD">_MM_PERM_CCAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCBA">_MM_PERM_CCBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCBB">_MM_PERM_CCBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCBC">_MM_PERM_CCBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCBD">_MM_PERM_CCBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCCA">_MM_PERM_CCCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCCB">_MM_PERM_CCCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCCC">_MM_PERM_CCCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCCD">_MM_PERM_CCCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCDA">_MM_PERM_CCDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCDB">_MM_PERM_CCDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCDC">_MM_PERM_CCDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CCDD">_MM_PERM_CCDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDAA">_MM_PERM_CDAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDAB">_MM_PERM_CDAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDAC">_MM_PERM_CDAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDAD">_MM_PERM_CDAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDBA">_MM_PERM_CDBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDBB">_MM_PERM_CDBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDBC">_MM_PERM_CDBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDBD">_MM_PERM_CDBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDCA">_MM_PERM_CDCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDCB">_MM_PERM_CDCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDCC">_MM_PERM_CDCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDCD">_MM_PERM_CDCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDDA">_MM_PERM_CDDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDDB">_MM_PERM_CDDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDDC">_MM_PERM_CDDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_CDDD">_MM_PERM_CDDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DAAA">_MM_PERM_DAAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DAAB">_MM_PERM_DAAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DAAC">_MM_PERM_DAAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DAAD">_MM_PERM_DAAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DABA">_MM_PERM_DABA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DABB">_MM_PERM_DABB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DABC">_MM_PERM_DABC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DABD">_MM_PERM_DABD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DACA">_MM_PERM_DACA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DACB">_MM_PERM_DACB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DACC">_MM_PERM_DACC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DACD">_MM_PERM_DACD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DADA">_MM_PERM_DADA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DADB">_MM_PERM_DADB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DADC">_MM_PERM_DADC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DADD">_MM_PERM_DADD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBAA">_MM_PERM_DBAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBAB">_MM_PERM_DBAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBAC">_MM_PERM_DBAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBAD">_MM_PERM_DBAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBBA">_MM_PERM_DBBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBBB">_MM_PERM_DBBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBBC">_MM_PERM_DBBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBBD">_MM_PERM_DBBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBCA">_MM_PERM_DBCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBCB">_MM_PERM_DBCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBCC">_MM_PERM_DBCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBCD">_MM_PERM_DBCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBDA">_MM_PERM_DBDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBDB">_MM_PERM_DBDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBDC">_MM_PERM_DBDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DBDD">_MM_PERM_DBDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCAA">_MM_PERM_DCAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCAB">_MM_PERM_DCAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCAC">_MM_PERM_DCAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCAD">_MM_PERM_DCAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCBA">_MM_PERM_DCBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCBB">_MM_PERM_DCBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCBC">_MM_PERM_DCBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCBD">_MM_PERM_DCBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCCA">_MM_PERM_DCCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCCB">_MM_PERM_DCCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCCC">_MM_PERM_DCCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCCD">_MM_PERM_DCCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCDA">_MM_PERM_DCDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCDB">_MM_PERM_DCDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCDC">_MM_PERM_DCDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DCDD">_MM_PERM_DCDD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDAA">_MM_PERM_DDAA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDAB">_MM_PERM_DDAB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDAC">_MM_PERM_DDAC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDAD">_MM_PERM_DDAD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDBA">_MM_PERM_DDBA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDBB">_MM_PERM_DDBB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDBC">_MM_PERM_DDBC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDBD">_MM_PERM_DDBD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDCA">_MM_PERM_DDCA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDCB">_MM_PERM_DDCB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDCC">_MM_PERM_DDCC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDCD">_MM_PERM_DDCD</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDA.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDDA">_MM_PERM_DDDA</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDB.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDDB">_MM_PERM_DDDB</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDC.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDDC">_MM_PERM_DDDC</a><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDD.html" title="constant core::core_arch::x86::avx512f::_MM_PERM_DDDD">_MM_PERM_DDDD</a><span class="stab unstable" title="">Experimental</span></div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn._kand_mask16.html" title="fn core::core_arch::x86::avx512f::_kand_mask16">_kand_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._kandn_mask16.html" title="fn core::core_arch::x86::avx512f::_kandn_mask16">_kandn_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._knot_mask16.html" title="fn core::core_arch::x86::avx512f::_knot_mask16">_knot_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 16-bit mask a, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._kor_mask16.html" title="fn core::core_arch::x86::avx512f::_kor_mask16">_kor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxnor_mask16.html" title="fn core::core_arch::x86::avx512f::_kxnor_mask16">_kxnor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxor_mask16.html" title="fn core::core_arch::x86::avx512f::_kxor_mask16">_kxor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_abs_epi64">_mm256_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_alignr_epi32">_mm256_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_alignr_epi64">_mm256_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_broadcast_f32x4">_mm256_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_broadcast_i32x4">_mm256_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_epi32_mask">_mm256_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_epi64_mask">_mm256_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_epu32_mask">_mm256_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_epu64_mask">_mm256_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_pd_mask">_mm256_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmp_ps_mask">_mm256_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpeq_epi32_mask">_mm256_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpeq_epi64_mask">_mm256_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpeq_epu32_mask">_mm256_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpeq_epu64_mask">_mm256_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpge_epi32_mask">_mm256_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpge_epi64_mask">_mm256_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpge_epu32_mask">_mm256_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpge_epu64_mask">_mm256_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpgt_epi32_mask">_mm256_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpgt_epi64_mask">_mm256_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpgt_epu32_mask">_mm256_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpgt_epu64_mask">_mm256_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmple_epi32_mask">_mm256_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmple_epi64_mask">_mm256_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmple_epu32_mask">_mm256_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmple_epu64_mask">_mm256_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmplt_epi32_mask">_mm256_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmplt_epi64_mask">_mm256_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmplt_epu32_mask">_mm256_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmplt_epu64_mask">_mm256_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpneq_epi32_mask">_mm256_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpneq_epi64_mask">_mm256_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpneq_epu32_mask">_mm256_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_cmpneq_epu64_mask">_mm256_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepi32_epi8">_mm256_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepi32_epi16">_mm256_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepi64_epi8">_mm256_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepi64_epi16">_mm256_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepi64_epi32">_mm256_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtepu32_pd">_mm256_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtpd_epu32">_mm256_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtps_epu32">_mm256_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtsepi32_epi8">_mm256_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtsepi32_epi16">_mm256_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtsepi64_epi8">_mm256_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtsepi64_epi16">_mm256_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtsepi64_epi32">_mm256_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvttpd_epu32">_mm256_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvttps_epu32">_mm256_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtusepi32_epi8">_mm256_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtusepi32_epi16">_mm256_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtusepi64_epi8">_mm256_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtusepi64_epi16">_mm256_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_cvtusepi64_epi32">_mm256_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_extractf32x4_ps">_mm256_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_extracti32x4_epi32">_mm256_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_fixupimm_pd">_mm256_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_fixupimm_ps">_mm256_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_getexp_pd">_mm256_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_getexp_ps">_mm256_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_getmant_pd">_mm256_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_getmant_ps">_mm256_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32scatter_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_i32scatter_epi64">_mm256_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_insertf32x4">_mm256_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_inserti32x4">_mm256_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_load_epi32">_mm256_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_load_epi64">_mm256_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_loadu_epi32">_mm256_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_loadu_epi64">_mm256_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask2_permutex2var_epi32">_mm256_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask2_permutex2var_epi64">_mm256_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask2_permutex2var_pd">_mm256_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask2_permutex2var_ps">_mm256_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmadd_pd">_mm256_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmadd_ps">_mm256_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmaddsub_pd">_mm256_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmaddsub_ps">_mm256_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmsub_pd">_mm256_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmsub_ps">_mm256_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmsubadd_pd">_mm256_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fmsubadd_ps">_mm256_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fnmadd_pd">_mm256_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fnmadd_ps">_mm256_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fnmsub_pd">_mm256_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask3_fnmsub_ps">_mm256_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_abs_epi32">_mm256_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_abs_epi64">_mm256_mask_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_add_epi32">_mm256_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_add_epi64">_mm256_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_add_pd">_mm256_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_add_ps">_mm256_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_alignr_epi32">_mm256_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_alignr_epi64">_mm256_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_and_epi32">_mm256_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_and_epi64">_mm256_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_andnot_epi32">_mm256_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_andnot_epi64">_mm256_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_blend_epi32">_mm256_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_blend_epi64">_mm256_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_blend_pd">_mm256_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_blend_ps">_mm256_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcast_f32x4">_mm256_mask_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcast_i32x4">_mm256_mask_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcastd_epi32">_mm256_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcastq_epi64">_mm256_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastsd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcastsd_pd">_mm256_mask_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_broadcastss_ps">_mm256_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_epi32_mask">_mm256_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_epi64_mask">_mm256_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_epu32_mask">_mm256_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_epu64_mask">_mm256_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_pd_mask">_mm256_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmp_ps_mask">_mm256_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpeq_epi32_mask">_mm256_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpeq_epi64_mask">_mm256_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpeq_epu32_mask">_mm256_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpeq_epu64_mask">_mm256_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpge_epi32_mask">_mm256_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpge_epi64_mask">_mm256_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpge_epu32_mask">_mm256_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpge_epu64_mask">_mm256_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpgt_epi32_mask">_mm256_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpgt_epi64_mask">_mm256_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpgt_epu32_mask">_mm256_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpgt_epu64_mask">_mm256_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmple_epi32_mask">_mm256_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmple_epi64_mask">_mm256_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmple_epu32_mask">_mm256_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmple_epu64_mask">_mm256_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmplt_epi32_mask">_mm256_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmplt_epi64_mask">_mm256_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmplt_epu32_mask">_mm256_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmplt_epu64_mask">_mm256_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpneq_epi32_mask">_mm256_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpneq_epi64_mask">_mm256_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpneq_epu32_mask">_mm256_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cmpneq_epu64_mask">_mm256_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compress_epi32">_mm256_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compress_epi64">_mm256_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compress_pd">_mm256_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compress_ps">_mm256_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compressstoreu_epi32">_mm256_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compressstoreu_epi64">_mm256_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compressstoreu_pd">_mm256_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_compressstoreu_ps">_mm256_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvt_roundps_ph">_mm256_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi8_epi32">_mm256_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi8_epi64">_mm256_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi16_epi32">_mm256_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi16_epi64">_mm256_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_epi8">_mm256_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_epi16">_mm256_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_epi64">_mm256_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_pd">_mm256_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_ps">_mm256_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_storeu_epi8">_mm256_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi32_storeu_epi16">_mm256_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_epi8">_mm256_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_epi16">_mm256_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_epi32">_mm256_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_storeu_epi8">_mm256_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_storeu_epi16">_mm256_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepi64_storeu_epi32">_mm256_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu8_epi32">_mm256_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu8_epi64">_mm256_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu16_epi32">_mm256_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu16_epi64">_mm256_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu32_epi64">_mm256_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtepu32_pd">_mm256_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtpd_epi32">_mm256_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtpd_epu32">_mm256_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtpd_ps">_mm256_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtph_ps">_mm256_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtps_epi32">_mm256_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtps_epu32">_mm256_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtps_ph">_mm256_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi32_epi8">_mm256_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi32_epi16">_mm256_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi32_storeu_epi8">_mm256_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi32_storeu_epi16">_mm256_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_epi8">_mm256_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_epi16">_mm256_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_epi32">_mm256_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_storeu_epi8">_mm256_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_storeu_epi16">_mm256_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtsepi64_storeu_epi32">_mm256_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvttpd_epi32">_mm256_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvttpd_epu32">_mm256_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvttps_epi32">_mm256_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvttps_epu32">_mm256_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi32_epi8">_mm256_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi32_epi16">_mm256_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi32_storeu_epi8">_mm256_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi32_storeu_epi16">_mm256_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_epi8">_mm256_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_epi16">_mm256_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_epi32">_mm256_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_storeu_epi8">_mm256_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_storeu_epi16">_mm256_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_cvtusepi64_storeu_epi32">_mm256_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_div_pd">_mm256_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_div_ps">_mm256_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expand_epi32">_mm256_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expand_epi64">_mm256_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expand_pd">_mm256_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expand_ps">_mm256_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expandloadu_epi32">_mm256_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expandloadu_epi64">_mm256_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expandloadu_pd">_mm256_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_expandloadu_ps">_mm256_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_extractf32x4_ps">_mm256_mask_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_extracti32x4_epi32">_mm256_mask_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fixupimm_pd">_mm256_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fixupimm_ps">_mm256_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmadd_pd">_mm256_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmadd_ps">_mm256_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmaddsub_pd">_mm256_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmaddsub_ps">_mm256_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmsub_pd">_mm256_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmsub_ps">_mm256_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmsubadd_pd">_mm256_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fmsubadd_ps">_mm256_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fnmadd_pd">_mm256_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fnmadd_ps">_mm256_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fnmsub_pd">_mm256_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_fnmsub_ps">_mm256_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_getexp_pd">_mm256_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_getexp_ps">_mm256_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_getmant_pd">_mm256_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_getmant_ps">_mm256_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_insertf32x4">_mm256_mask_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_inserti32x4">_mm256_mask_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_load_epi32">_mm256_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_load_epi64">_mm256_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_load_pd">_mm256_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_load_ps">_mm256_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_loadu_epi32">_mm256_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_loadu_epi64">_mm256_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_loadu_pd">_mm256_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_loadu_ps">_mm256_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_epi32">_mm256_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_epi64">_mm256_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_epu32">_mm256_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_epu64">_mm256_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_pd">_mm256_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_max_ps">_mm256_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_epi32">_mm256_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_epi64">_mm256_mask_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_epu32">_mm256_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_epu64">_mm256_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_pd">_mm256_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_min_ps">_mm256_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mov_epi32">_mm256_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mov_epi64">_mm256_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mov_pd">_mm256_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mov_ps">_mm256_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_movedup_pd">_mm256_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_movehdup_ps">_mm256_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_moveldup_ps">_mm256_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mul_epi32">_mm256_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mul_epu32">_mm256_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mul_pd">_mm256_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mul_ps">_mm256_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_mullo_epi32">_mm256_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_or_epi32">_mm256_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_or_epi64">_mm256_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permute_pd">_mm256_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permute_ps">_mm256_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutevar_pd">_mm256_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutevar_ps">_mm256_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex2var_epi32">_mm256_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex2var_epi64">_mm256_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex2var_pd">_mm256_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex2var_ps">_mm256_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex_epi64">_mm256_mask_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutex_pd">_mm256_mask_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutexvar_epi32">_mm256_mask_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutexvar_epi64">_mm256_mask_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutexvar_pd">_mm256_mask_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_permutexvar_ps">_mm256_mask_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rcp14_pd">_mm256_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rcp14_ps">_mm256_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rol_epi32">_mm256_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rol_epi64">_mm256_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rolv_epi32">_mm256_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rolv_epi64">_mm256_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_ror_epi32">_mm256_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_ror_epi64">_mm256_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rorv_epi32">_mm256_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rorv_epi64">_mm256_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_roundscale_pd">_mm256_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_roundscale_ps">_mm256_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rsqrt14_pd">_mm256_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_rsqrt14_ps">_mm256_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_scalef_pd">_mm256_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_scalef_ps">_mm256_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_set1_epi32">_mm256_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_set1_epi64">_mm256_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_epi32">_mm256_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_f32x4">_mm256_mask_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_f64x2">_mm256_mask_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_i32x4">_mm256_mask_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_i64x2">_mm256_mask_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_pd">_mm256_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_shuffle_ps">_mm256_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sll_epi32">_mm256_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sll_epi64">_mm256_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_slli_epi32">_mm256_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_slli_epi64">_mm256_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sllv_epi32">_mm256_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sllv_epi64">_mm256_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sqrt_pd">_mm256_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sqrt_ps">_mm256_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sra_epi32">_mm256_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sra_epi64">_mm256_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srai_epi32">_mm256_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srai_epi64">_mm256_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srav_epi32">_mm256_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srav_epi64">_mm256_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srl_epi32">_mm256_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srl_epi64">_mm256_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srli_epi32">_mm256_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srli_epi64">_mm256_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srlv_epi32">_mm256_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_srlv_epi64">_mm256_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_store_epi32">_mm256_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_store_epi64">_mm256_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_store_pd">_mm256_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_store_ps">_mm256_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_storeu_epi32">_mm256_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_storeu_epi64">_mm256_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_storeu_pd">_mm256_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_storeu_ps">_mm256_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sub_epi32">_mm256_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sub_epi64">_mm256_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sub_pd">_mm256_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_sub_ps">_mm256_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_ternarylogic_epi32">_mm256_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_ternarylogic_epi64">_mm256_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_test_epi32_mask">_mm256_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_test_epi64_mask">_mm256_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_testn_epi32_mask">_mm256_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_testn_epi64_mask">_mm256_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpackhi_epi32">_mm256_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpackhi_epi64">_mm256_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpackhi_pd">_mm256_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpackhi_ps">_mm256_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpacklo_epi32">_mm256_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpacklo_epi64">_mm256_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpacklo_pd">_mm256_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_unpacklo_ps">_mm256_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_xor_epi32">_mm256_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_mask_xor_epi64">_mm256_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_abs_epi32">_mm256_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_abs_epi64">_mm256_maskz_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_add_epi32">_mm256_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_add_epi64">_mm256_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_add_pd">_mm256_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_add_ps">_mm256_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_alignr_epi32">_mm256_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_alignr_epi64">_mm256_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_and_epi32">_mm256_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_and_epi64">_mm256_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_andnot_epi32">_mm256_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_andnot_epi64">_mm256_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcast_f32x4">_mm256_maskz_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcast_i32x4">_mm256_maskz_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcastd_epi32">_mm256_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcastq_epi64">_mm256_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastsd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcastsd_pd">_mm256_maskz_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_broadcastss_ps">_mm256_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_compress_epi32">_mm256_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_compress_epi64">_mm256_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_compress_pd">_mm256_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_compress_ps">_mm256_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvt_roundps_ph">_mm256_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi8_epi32">_mm256_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi8_epi64">_mm256_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi16_epi32">_mm256_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi16_epi64">_mm256_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi32_epi8">_mm256_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi32_epi16">_mm256_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi32_epi64">_mm256_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi32_pd">_mm256_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi32_ps">_mm256_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi64_epi8">_mm256_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi64_epi16">_mm256_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepi64_epi32">_mm256_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu8_epi32">_mm256_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu8_epi64">_mm256_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu16_epi32">_mm256_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu16_epi64">_mm256_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu32_epi64">_mm256_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtepu32_pd">_mm256_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtpd_epi32">_mm256_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtpd_epu32">_mm256_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtpd_ps">_mm256_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtph_ps">_mm256_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtps_epi32">_mm256_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtps_epu32">_mm256_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtps_ph">_mm256_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtsepi32_epi8">_mm256_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtsepi32_epi16">_mm256_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtsepi64_epi8">_mm256_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtsepi64_epi16">_mm256_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtsepi64_epi32">_mm256_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvttpd_epi32">_mm256_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvttpd_epu32">_mm256_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvttps_epi32">_mm256_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvttps_epu32">_mm256_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtusepi32_epi8">_mm256_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtusepi32_epi16">_mm256_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtusepi64_epi8">_mm256_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtusepi64_epi16">_mm256_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_cvtusepi64_epi32">_mm256_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_div_pd">_mm256_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_div_ps">_mm256_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expand_epi32">_mm256_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expand_epi64">_mm256_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expand_pd">_mm256_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expand_ps">_mm256_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expandloadu_epi32">_mm256_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expandloadu_epi64">_mm256_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expandloadu_pd">_mm256_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_expandloadu_ps">_mm256_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_extractf32x4_ps">_mm256_maskz_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_extracti32x4_epi32">_mm256_maskz_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fixupimm_pd">_mm256_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fixupimm_ps">_mm256_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmadd_pd">_mm256_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmadd_ps">_mm256_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmaddsub_pd">_mm256_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmaddsub_ps">_mm256_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmsub_pd">_mm256_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmsub_ps">_mm256_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmsubadd_pd">_mm256_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fmsubadd_ps">_mm256_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fnmadd_pd">_mm256_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fnmadd_ps">_mm256_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fnmsub_pd">_mm256_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_fnmsub_ps">_mm256_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_getexp_pd">_mm256_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_getexp_ps">_mm256_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_getmant_pd">_mm256_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_getmant_ps">_mm256_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_insertf32x4">_mm256_maskz_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_inserti32x4">_mm256_maskz_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_load_epi32">_mm256_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_load_epi64">_mm256_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_load_pd">_mm256_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_load_ps">_mm256_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_loadu_epi32">_mm256_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_loadu_epi64">_mm256_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_loadu_pd">_mm256_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_loadu_ps">_mm256_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_epi32">_mm256_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_epi64">_mm256_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_epu32">_mm256_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_epu64">_mm256_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_pd">_mm256_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_max_ps">_mm256_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_epi32">_mm256_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_epi64">_mm256_maskz_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_epu32">_mm256_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_epu64">_mm256_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_pd">_mm256_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_min_ps">_mm256_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mov_epi32">_mm256_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mov_epi64">_mm256_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mov_pd">_mm256_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mov_ps">_mm256_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_movedup_pd">_mm256_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_movehdup_ps">_mm256_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_moveldup_ps">_mm256_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mul_epi32">_mm256_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mul_epu32">_mm256_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mul_pd">_mm256_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mul_ps">_mm256_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_mullo_epi32">_mm256_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_or_epi32">_mm256_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_or_epi64">_mm256_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permute_pd">_mm256_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permute_ps">_mm256_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutevar_pd">_mm256_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutevar_ps">_mm256_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex2var_epi32">_mm256_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex2var_epi64">_mm256_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex2var_pd">_mm256_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex2var_ps">_mm256_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex_epi64">_mm256_maskz_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutex_pd">_mm256_maskz_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutexvar_epi32">_mm256_maskz_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutexvar_epi64">_mm256_maskz_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutexvar_pd">_mm256_maskz_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_permutexvar_ps">_mm256_maskz_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rcp14_pd">_mm256_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rcp14_ps">_mm256_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rol_epi32">_mm256_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rol_epi64">_mm256_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rolv_epi32">_mm256_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rolv_epi64">_mm256_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_ror_epi32">_mm256_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_ror_epi64">_mm256_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rorv_epi32">_mm256_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rorv_epi64">_mm256_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_roundscale_pd">_mm256_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_roundscale_ps">_mm256_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rsqrt14_pd">_mm256_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_rsqrt14_ps">_mm256_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_scalef_pd">_mm256_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_scalef_ps">_mm256_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_set1_epi32">_mm256_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_set1_epi64">_mm256_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_epi32">_mm256_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_f32x4">_mm256_maskz_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_f64x2">_mm256_maskz_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_i32x4">_mm256_maskz_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_i64x2">_mm256_maskz_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_pd">_mm256_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_shuffle_ps">_mm256_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sll_epi32">_mm256_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sll_epi64">_mm256_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_slli_epi32">_mm256_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_slli_epi64">_mm256_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sllv_epi32">_mm256_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sllv_epi64">_mm256_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sqrt_pd">_mm256_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sqrt_ps">_mm256_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sra_epi32">_mm256_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sra_epi64">_mm256_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srai_epi32">_mm256_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srai_epi64">_mm256_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srav_epi32">_mm256_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srav_epi64">_mm256_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srl_epi32">_mm256_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srl_epi64">_mm256_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srli_epi32">_mm256_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srli_epi64">_mm256_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srlv_epi32">_mm256_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_srlv_epi64">_mm256_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sub_epi32">_mm256_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sub_epi64">_mm256_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sub_pd">_mm256_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_sub_ps">_mm256_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_ternarylogic_epi32">_mm256_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_ternarylogic_epi64">_mm256_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpackhi_epi32">_mm256_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpackhi_epi64">_mm256_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpackhi_pd">_mm256_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpackhi_ps">_mm256_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpacklo_epi32">_mm256_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpacklo_epi64">_mm256_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpacklo_pd">_mm256_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_unpacklo_ps">_mm256_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_xor_epi32">_mm256_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_maskz_xor_epi64">_mm256_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_max_epi64">_mm256_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_max_epu64">_mm256_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_min_epi64">_mm256_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm256_min_epu64">_mm256_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_or_epi32">_mm256_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_or_epi64">_mm256_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex2var_epi32">_mm256_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex2var_epi64">_mm256_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex2var_pd">_mm256_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex2var_ps">_mm256_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex_epi64">_mm256_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_permutex_pd">_mm256_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_permutexvar_epi32">_mm256_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_permutexvar_epi64">_mm256_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_permutexvar_pd">_mm256_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_permutexvar_ps">_mm256_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_rcp14_pd">_mm256_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_rcp14_ps">_mm256_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_rol_epi32">_mm256_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_rol_epi64">_mm256_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_rolv_epi32">_mm256_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_rolv_epi64">_mm256_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_ror_epi32">_mm256_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_ror_epi64">_mm256_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_rorv_epi32">_mm256_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_rorv_epi64">_mm256_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_roundscale_pd">_mm256_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_roundscale_ps">_mm256_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm256_scalef_pd">_mm256_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm256_scalef_ps">_mm256_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_shuffle_f32x4">_mm256_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_shuffle_f64x2">_mm256_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm256_shuffle_i32x4">_mm256_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm256_shuffle_i64x2">_mm256_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_sra_epi64">_mm256_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_srai_epi64">_mm256_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_srav_epi64">_mm256_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_store_epi32">_mm256_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_store_epi64">_mm256_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_storeu_epi32">_mm256_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_storeu_epi64">_mm256_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_ternarylogic_epi32">_mm256_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_ternarylogic_epi64">_mm256_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_test_epi32_mask">_mm256_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_test_epi64_mask">_mm256_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_testn_epi32_mask">_mm256_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm256_testn_epi64_mask">_mm256_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm256_xor_epi32">_mm256_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm256_xor_epi64">_mm256_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_abs_epi32">_mm512_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Computes the absolute values of packed 32-bit integers in <code>a</code>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_abs_epi64">_mm512_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_abs_pd">_mm512_abs_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_abs_ps">_mm512_abs_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_add_epi32">_mm512_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_add_epi64">_mm512_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_add_pd">_mm512_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_add_ps">_mm512_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_add_round_pd">_mm512_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_add_round_ps">_mm512_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_alignr_epi32">_mm512_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_alignr_epi64">_mm512_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_and_epi32">_mm512_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_and_epi64">_mm512_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_and_si512">_mm512_and_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_andnot_epi32">_mm512_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_andnot_epi64">_mm512_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in a and then AND with b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_andnot_si512">_mm512_andnot_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 512 bits (representing integer data) in a and then AND with b, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcast_f32x4">_mm512_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_f64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcast_f64x4">_mm512_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcast_i32x4">_mm512_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_i64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcast_i64x4">_mm512_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 64-bit integers from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcastd_epi32">_mm512_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcastq_epi64">_mm512_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastsd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcastsd_pd">_mm512_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_broadcastss_ps">_mm512_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd128_pd512.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd128_pd512">_mm512_castpd128_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd256_pd512.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd256_pd512">_mm512_castpd256_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd512_pd128.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd512_pd128">_mm512_castpd512_pd128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512d to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd512_pd256.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd512_pd256">_mm512_castpd512_pd256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512d to type __m256d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd_ps">_mm512_castpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512d to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_castpd_si512">_mm512_castpd_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512d to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps128_ps512.html" title="fn core::core_arch::x86::avx512f::_mm512_castps128_ps512">_mm512_castps128_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128 to type __m512; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps256_ps512.html" title="fn core::core_arch::x86::avx512f::_mm512_castps256_ps512">_mm512_castps256_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256 to type __m512; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps512_ps128.html" title="fn core::core_arch::x86::avx512f::_mm512_castps512_ps128">_mm512_castps512_ps128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512 to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps512_ps256.html" title="fn core::core_arch::x86::avx512f::_mm512_castps512_ps256">_mm512_castps512_ps256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512 to type __m256. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_castps_pd">_mm512_castps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512 to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_castps_si512">_mm512_castps_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512 to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi128_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi128_si512">_mm512_castsi128_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi256_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi256_si512">_mm512_castsi256_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi512_pd">_mm512_castsi512_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512i to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi512_ps">_mm512_castsi512_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512i to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_si128.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi512_si128">_mm512_castsi512_si128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512i to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_si256.html" title="fn core::core_arch::x86::avx512f::_mm512_castsi512_si256">_mm512_castsi512_si256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m512i to type __m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_epi32_mask">_mm512_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_epi64_mask">_mm512_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_epu32_mask">_mm512_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_epu64_mask">_mm512_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_pd_mask">_mm512_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_ps_mask">_mm512_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_round_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_round_pd_mask">_mm512_cmp_round_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_round_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmp_round_ps_mask">_mm512_cmp_round_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_epi32_mask">_mm512_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_epi64_mask">_mm512_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_epu32_mask">_mm512_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_epu64_mask">_mm512_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_pd_mask">_mm512_cmpeq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpeq_ps_mask">_mm512_cmpeq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpge_epi32_mask">_mm512_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpge_epi64_mask">_mm512_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpge_epu32_mask">_mm512_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpge_epu64_mask">_mm512_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpgt_epi32_mask">_mm512_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpgt_epi64_mask">_mm512_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpgt_epu32_mask">_mm512_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpgt_epu64_mask">_mm512_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_epi32_mask">_mm512_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_epi64_mask">_mm512_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_epu32_mask">_mm512_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_epu64_mask">_mm512_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_pd_mask">_mm512_cmple_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmple_ps_mask">_mm512_cmple_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_epi32_mask">_mm512_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_epi64_mask">_mm512_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_epu32_mask">_mm512_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_epu64_mask">_mm512_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_pd_mask">_mm512_cmplt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmplt_ps_mask">_mm512_cmplt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_epi32_mask">_mm512_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_epi64_mask">_mm512_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_epu32_mask">_mm512_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_epu64_mask">_mm512_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_pd_mask">_mm512_cmpneq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpneq_ps_mask">_mm512_cmpneq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnle_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpnle_pd_mask">_mm512_cmpnle_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnle_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpnle_ps_mask">_mm512_cmpnle_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnlt_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpnlt_pd_mask">_mm512_cmpnlt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnlt_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpnlt_ps_mask">_mm512_cmpnlt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpord_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpord_pd_mask">_mm512_cmpord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpord_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpord_ps_mask">_mm512_cmpord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpunord_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpunord_pd_mask">_mm512_cmpunord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpunord_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_cmpunord_ps_mask">_mm512_cmpunord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundepi32_ps">_mm512_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundepu32_ps">_mm512_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundpd_epi32">_mm512_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundpd_epu32">_mm512_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundpd_ps">_mm512_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundph_ps">_mm512_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundps_epi32">_mm512_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundps_epu32">_mm512_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundps_pd">_mm512_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_cvt_roundps_ph">_mm512_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi8_epi32">_mm512_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi8_epi64">_mm512_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi16_epi32">_mm512_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi16_epi64">_mm512_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32_epi8">_mm512_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32_epi16">_mm512_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32_epi64">_mm512_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32_pd">_mm512_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32_ps">_mm512_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32lo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi32lo_pd">_mm512_cvtepi32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi64_epi8">_mm512_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi64_epi16">_mm512_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepi64_epi32">_mm512_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu8_epi32">_mm512_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu8_epi64">_mm512_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu16_epi32">_mm512_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu16_epi64">_mm512_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu32_epi64">_mm512_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu32_pd">_mm512_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu32_ps">_mm512_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32lo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtepu32lo_pd">_mm512_cvtepu32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of packed 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtpd_epi32">_mm512_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtpd_epu32">_mm512_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtpd_ps">_mm512_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_pslo.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtpd_pslo">_mm512_cvtpd_pslo</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst. The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtph_ps">_mm512_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtps_epi32">_mm512_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtps_epu32">_mm512_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtps_pd">_mm512_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtps_ph">_mm512_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpslo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtpslo_pd">_mm512_cvtpslo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsepi32_epi8">_mm512_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsepi32_epi16">_mm512_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsepi64_epi8">_mm512_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsepi64_epi16">_mm512_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsepi64_epi32">_mm512_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsi512_si32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtsi512_si32">_mm512_cvtsi512_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy the lower 32-bit integer in a to dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtt_roundpd_epi32">_mm512_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtt_roundpd_epu32">_mm512_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtt_roundps_epi32">_mm512_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtt_roundps_epu32">_mm512_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvttpd_epi32">_mm512_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvttpd_epu32">_mm512_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvttps_epi32">_mm512_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvttps_epu32">_mm512_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtusepi32_epi8">_mm512_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtusepi32_epi16">_mm512_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtusepi64_epi8">_mm512_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtusepi64_epi16">_mm512_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_cvtusepi64_epi32">_mm512_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_div_pd">_mm512_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_div_ps">_mm512_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_div_round_pd">_mm512_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, =and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_div_round_ps">_mm512_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_extractf32x4_ps">_mm512_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extractf64x4_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_extractf64x4_pd">_mm512_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_extracti32x4_epi32">_mm512_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extracti64x4_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_extracti64x4_epi64">_mm512_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fixupimm_pd">_mm512_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fixupimm_ps">_mm512_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fixupimm_round_pd">_mm512_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fixupimm_round_ps">_mm512_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmadd_pd">_mm512_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmadd_ps">_mm512_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmadd_round_pd">_mm512_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmadd_round_ps">_mm512_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmaddsub_pd">_mm512_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmaddsub_ps">_mm512_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmaddsub_round_pd">_mm512_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmaddsub_round_ps">_mm512_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsub_pd">_mm512_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsub_ps">_mm512_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsub_round_pd">_mm512_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsub_round_ps">_mm512_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsubadd_pd">_mm512_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsubadd_ps">_mm512_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsubadd_round_pd">_mm512_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fmsubadd_round_ps">_mm512_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmadd_pd">_mm512_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmadd_ps">_mm512_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmadd_round_pd">_mm512_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmadd_round_ps">_mm512_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmsub_pd">_mm512_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmsub_ps">_mm512_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmsub_round_pd">_mm512_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_fnmsub_round_ps">_mm512_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_getexp_pd">_mm512_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_getexp_ps">_mm512_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_getexp_round_pd">_mm512_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_getexp_round_ps">_mm512_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_getmant_pd">_mm512_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_getmant_ps">_mm512_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_getmant_round_pd">_mm512_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_getmant_round_ps">_mm512_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_i32gather_epi32">_mm512_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_i32gather_epi64">_mm512_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_i32gather_pd">_mm512_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_i32gather_ps">_mm512_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_i32scatter_epi32">_mm512_i32scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_i32scatter_epi64">_mm512_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_i32scatter_pd">_mm512_i32scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_i32scatter_ps">_mm512_i32scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_i64gather_epi32">_mm512_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_i64gather_epi64">_mm512_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_i64gather_pd">_mm512_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_i64gather_ps">_mm512_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_i64scatter_epi32">_mm512_i64scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_i64scatter_epi64">_mm512_i64scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_i64scatter_pd">_mm512_i64scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_i64scatter_ps">_mm512_i64scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_insertf32x4">_mm512_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_insertf64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_insertf64x4">_mm512_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_inserti32x4">_mm512_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_inserti64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_inserti64x4">_mm512_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to dst, then insert 256 bits (composed of 4 packed 64-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_int2mask.html" title="fn core::core_arch::x86::avx512f::_mm512_int2mask">_mm512_int2mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Converts integer mask into bitmask, storing the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kand.html" title="fn core::core_arch::x86::avx512f::_mm512_kand">_mm512_kand</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kandn.html" title="fn core::core_arch::x86::avx512f::_mm512_kandn">_mm512_kandn</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kmov.html" title="fn core::core_arch::x86::avx512f::_mm512_kmov">_mm512_kmov</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy 16-bit mask a to k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_knot.html" title="fn core::core_arch::x86::avx512f::_mm512_knot">_mm512_knot</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of 16-bit mask a, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kor.html" title="fn core::core_arch::x86::avx512f::_mm512_kor">_mm512_kor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kortestc.html" title="fn core::core_arch::x86::avx512f::_mm512_kortestc">_mm512_kortestc</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs bitwise OR between k1 and k2, storing the result in dst. CF flag is set if dst consists of all 1’s.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kunpackb.html" title="fn core::core_arch::x86::avx512f::_mm512_kunpackb">_mm512_kunpackb</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 8 bits from masks a and b, and store the 16-bit result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kxnor.html" title="fn core::core_arch::x86::avx512f::_mm512_kxnor">_mm512_kxnor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kxor.html" title="fn core::core_arch::x86::avx512f::_mm512_kxor">_mm512_kxor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_load_epi32">_mm512_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_load_epi64">_mm512_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_load_pd">_mm512_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_load_ps">_mm512_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_load_si512">_mm512_load_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits of integer data from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_loadu_epi32">_mm512_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_loadu_epi64">_mm512_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_loadu_pd">_mm512_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Loads 512-bits (composed of 8 packed double-precision (64-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_loadu_ps">_mm512_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Loads 512-bits (composed of 16 packed single-precision (32-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_loadu_si512">_mm512_loadu_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load 512-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask2_permutex2var_epi32">_mm512_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask2_permutex2var_epi64">_mm512_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask2_permutex2var_pd">_mm512_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask2_permutex2var_ps">_mm512_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2int.html" title="fn core::core_arch::x86::avx512f::_mm512_mask2int">_mm512_mask2int</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Converts bit mask k1 into an integer value, storing the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmadd_pd">_mm512_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmadd_ps">_mm512_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmadd_round_pd">_mm512_mask3_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmadd_round_ps">_mm512_mask3_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmaddsub_pd">_mm512_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmaddsub_ps">_mm512_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmaddsub_round_pd">_mm512_mask3_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmaddsub_round_ps">_mm512_mask3_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsub_pd">_mm512_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsub_ps">_mm512_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsub_round_pd">_mm512_mask3_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsub_round_ps">_mm512_mask3_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsubadd_pd">_mm512_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsubadd_ps">_mm512_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsubadd_round_pd">_mm512_mask3_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fmsubadd_round_ps">_mm512_mask3_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmadd_pd">_mm512_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmadd_ps">_mm512_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmadd_round_pd">_mm512_mask3_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmadd_round_ps">_mm512_mask3_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmsub_pd">_mm512_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmsub_ps">_mm512_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmsub_round_pd">_mm512_mask3_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask3_fnmsub_round_ps">_mm512_mask3_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_abs_epi32">_mm512_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the
unsigned results in <code>dst</code> using writemask <code>k</code> (elements are copied from
<code>src</code> when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_abs_epi64">_mm512_mask_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_abs_pd">_mm512_mask_abs_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_abs_ps">_mm512_mask_abs_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_epi32">_mm512_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_epi64">_mm512_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_pd">_mm512_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_ps">_mm512_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_round_pd">_mm512_mask_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_add_round_ps">_mm512_mask_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_alignr_epi32">_mm512_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_alignr_epi64">_mm512_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_and_epi32">_mm512_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_and_epi64">_mm512_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_andnot_epi32">_mm512_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_andnot_epi64">_mm512_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_blend_epi32">_mm512_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_blend_epi64">_mm512_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_blend_pd">_mm512_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_blend_ps">_mm512_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcast_f32x4">_mm512_mask_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_f64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcast_f64x4">_mm512_mask_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcast_i32x4">_mm512_mask_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_i64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcast_i64x4">_mm512_mask_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 64-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcastd_epi32">_mm512_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcastq_epi64">_mm512_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastsd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcastsd_pd">_mm512_mask_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_broadcastss_ps">_mm512_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_epi32_mask">_mm512_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_epi64_mask">_mm512_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_epu32_mask">_mm512_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_epu64_mask">_mm512_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_pd_mask">_mm512_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_ps_mask">_mm512_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_round_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_round_pd_mask">_mm512_mask_cmp_round_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_round_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmp_round_ps_mask">_mm512_mask_cmp_round_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_epi32_mask">_mm512_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_epi64_mask">_mm512_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_epu32_mask">_mm512_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_epu64_mask">_mm512_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_pd_mask">_mm512_mask_cmpeq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpeq_ps_mask">_mm512_mask_cmpeq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpge_epi32_mask">_mm512_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpge_epi64_mask">_mm512_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpge_epu32_mask">_mm512_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpge_epu64_mask">_mm512_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpgt_epi32_mask">_mm512_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpgt_epi64_mask">_mm512_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpgt_epu32_mask">_mm512_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpgt_epu64_mask">_mm512_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_epi32_mask">_mm512_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_epi64_mask">_mm512_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_epu32_mask">_mm512_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_epu64_mask">_mm512_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_pd_mask">_mm512_mask_cmple_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmple_ps_mask">_mm512_mask_cmple_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_epi32_mask">_mm512_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_epi64_mask">_mm512_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_epu32_mask">_mm512_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_epu64_mask">_mm512_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_pd_mask">_mm512_mask_cmplt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmplt_ps_mask">_mm512_mask_cmplt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_epi32_mask">_mm512_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_epi64_mask">_mm512_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_epu32_mask">_mm512_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_epu64_mask">_mm512_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_pd_mask">_mm512_mask_cmpneq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpneq_ps_mask">_mm512_mask_cmpneq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnle_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpnle_pd_mask">_mm512_mask_cmpnle_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnle_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpnle_ps_mask">_mm512_mask_cmpnle_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnlt_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpnlt_pd_mask">_mm512_mask_cmpnlt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnlt_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpnlt_ps_mask">_mm512_mask_cmpnlt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpord_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpord_pd_mask">_mm512_mask_cmpord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpord_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpord_ps_mask">_mm512_mask_cmpord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpunord_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpunord_pd_mask">_mm512_mask_cmpunord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpunord_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cmpunord_ps_mask">_mm512_mask_cmpunord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compress_epi32">_mm512_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compress_epi64">_mm512_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compress_pd">_mm512_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compress_ps">_mm512_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compressstoreu_epi32">_mm512_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compressstoreu_epi64">_mm512_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compressstoreu_pd">_mm512_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_compressstoreu_ps">_mm512_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundepi32_ps">_mm512_mask_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundepu32_ps">_mm512_mask_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundpd_epi32">_mm512_mask_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundpd_epu32">_mm512_mask_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundpd_ps">_mm512_mask_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundph_ps">_mm512_mask_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundps_epi32">_mm512_mask_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundps_epu32">_mm512_mask_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundps_pd">_mm512_mask_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvt_roundps_ph">_mm512_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi8_epi32">_mm512_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi8_epi64">_mm512_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi16_epi32">_mm512_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi16_epi64">_mm512_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_epi8">_mm512_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_epi16">_mm512_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_epi64">_mm512_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_pd">_mm512_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_ps">_mm512_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_storeu_epi8">_mm512_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32_storeu_epi16">_mm512_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32lo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi32lo_pd">_mm512_mask_cvtepi32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_epi8">_mm512_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_epi16">_mm512_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_epi32">_mm512_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_storeu_epi8">_mm512_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_storeu_epi16">_mm512_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepi64_storeu_epi32">_mm512_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu8_epi32">_mm512_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu8_epi64">_mm512_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu16_epi32">_mm512_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu16_epi64">_mm512_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu32_epi64">_mm512_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu32_pd">_mm512_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu32_ps">_mm512_mask_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32lo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtepu32lo_pd">_mm512_mask_cvtepu32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtpd_epi32">_mm512_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtpd_epu32">_mm512_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtpd_ps">_mm512_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_pslo.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtpd_pslo">_mm512_mask_cvtpd_pslo</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtph_ps">_mm512_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtps_epi32">_mm512_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtps_epu32">_mm512_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtps_pd">_mm512_mask_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtps_ph">_mm512_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpslo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtpslo_pd">_mm512_mask_cvtpslo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi32_epi8">_mm512_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi32_epi16">_mm512_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi32_storeu_epi8">_mm512_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi32_storeu_epi16">_mm512_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_epi8">_mm512_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_epi16">_mm512_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_epi32">_mm512_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_storeu_epi8">_mm512_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_storeu_epi16">_mm512_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtsepi64_storeu_epi32">_mm512_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtt_roundpd_epi32">_mm512_mask_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtt_roundpd_epu32">_mm512_mask_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtt_roundps_epi32">_mm512_mask_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtt_roundps_epu32">_mm512_mask_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvttpd_epi32">_mm512_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvttpd_epu32">_mm512_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvttps_epi32">_mm512_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvttps_epu32">_mm512_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi32_epi8">_mm512_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi32_epi16">_mm512_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi32_storeu_epi8">_mm512_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi32_storeu_epi16">_mm512_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_epi8">_mm512_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_epi16">_mm512_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_epi32">_mm512_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_storeu_epi8">_mm512_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_storeu_epi16">_mm512_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_cvtusepi64_storeu_epi32">_mm512_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_div_pd">_mm512_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_div_ps">_mm512_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_div_round_pd">_mm512_mask_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_div_round_ps">_mm512_mask_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expand_epi32">_mm512_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expand_epi64">_mm512_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expand_pd">_mm512_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expand_ps">_mm512_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expandloadu_epi32">_mm512_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expandloadu_epi64">_mm512_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expandloadu_pd">_mm512_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_expandloadu_ps">_mm512_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_extractf32x4_ps">_mm512_mask_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extractf64x4_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_extractf64x4_pd">_mm512_mask_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_extracti32x4_epi32">_mm512_mask_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extracti64x4_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_extracti64x4_epi64">_mm512_mask_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fixupimm_pd">_mm512_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fixupimm_ps">_mm512_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fixupimm_round_pd">_mm512_mask_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fixupimm_round_ps">_mm512_mask_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmadd_pd">_mm512_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmadd_ps">_mm512_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmadd_round_pd">_mm512_mask_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmadd_round_ps">_mm512_mask_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmaddsub_pd">_mm512_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmaddsub_ps">_mm512_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmaddsub_round_pd">_mm512_mask_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmaddsub_round_ps">_mm512_mask_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsub_pd">_mm512_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsub_ps">_mm512_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsub_round_pd">_mm512_mask_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsub_round_ps">_mm512_mask_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsubadd_pd">_mm512_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsubadd_ps">_mm512_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsubadd_round_pd">_mm512_mask_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fmsubadd_round_ps">_mm512_mask_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmadd_pd">_mm512_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmadd_ps">_mm512_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmadd_round_pd">_mm512_mask_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmadd_round_ps">_mm512_mask_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmsub_pd">_mm512_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmsub_ps">_mm512_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmsub_round_pd">_mm512_mask_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_fnmsub_round_ps">_mm512_mask_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getexp_pd">_mm512_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getexp_ps">_mm512_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getexp_round_pd">_mm512_mask_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getexp_round_ps">_mm512_mask_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getmant_pd">_mm512_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getmant_ps">_mm512_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getmant_round_pd">_mm512_mask_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_getmant_round_ps">_mm512_mask_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32gather_epi32">_mm512_mask_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32gather_epi64">_mm512_mask_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32gather_pd">_mm512_mask_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32gather_ps">_mm512_mask_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32scatter_epi32">_mm512_mask_i32scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32scatter_epi64">_mm512_mask_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32scatter_pd">_mm512_mask_i32scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i32scatter_ps">_mm512_mask_i32scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64gather_epi32">_mm512_mask_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64gather_epi64">_mm512_mask_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64gather_pd">_mm512_mask_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64gather_ps">_mm512_mask_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64scatter_epi32">_mm512_mask_i64scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64scatter_epi64">_mm512_mask_i64scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64scatter_pd">_mm512_mask_i64scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_i64scatter_ps">_mm512_mask_i64scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_insertf32x4">_mm512_mask_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_insertf64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_insertf64x4">_mm512_mask_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_inserti32x4">_mm512_mask_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_inserti64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_inserti64x4">_mm512_mask_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_load_epi32">_mm512_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_load_epi64">_mm512_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_load_pd">_mm512_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_load_ps">_mm512_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_loadu_epi32">_mm512_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_loadu_epi64">_mm512_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_loadu_pd">_mm512_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_loadu_ps">_mm512_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_epi32">_mm512_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_epi64">_mm512_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_epu32">_mm512_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_epu64">_mm512_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_pd">_mm512_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_ps">_mm512_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_round_pd">_mm512_mask_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_max_round_ps">_mm512_mask_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_epi32">_mm512_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_epi64">_mm512_mask_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_epu32">_mm512_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_epu64">_mm512_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_pd">_mm512_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_ps">_mm512_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_round_pd">_mm512_mask_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_min_round_ps">_mm512_mask_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mov_epi32">_mm512_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mov_epi64">_mm512_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mov_pd">_mm512_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mov_ps">_mm512_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_movedup_pd">_mm512_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_movehdup_ps">_mm512_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_moveldup_ps">_mm512_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_epi32">_mm512_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_epu32">_mm512_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_pd">_mm512_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_ps">_mm512_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_round_pd">_mm512_mask_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mul_round_ps">_mm512_mask_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mullo_epi32">_mm512_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mullox_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_mullox_epi64">_mm512_mask_mullox_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_or_epi32">_mm512_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_or_epi64">_mm512_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permute_pd">_mm512_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permute_ps">_mm512_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutevar_epi32">_mm512_mask_permutevar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_mask_permutexvar_epi32, and it is recommended that you use that intrinsic name.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutevar_pd">_mm512_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutevar_ps">_mm512_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex2var_epi32">_mm512_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex2var_epi64">_mm512_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex2var_pd">_mm512_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex2var_ps">_mm512_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex_epi64">_mm512_mask_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutex_pd">_mm512_mask_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutexvar_epi32">_mm512_mask_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutexvar_epi64">_mm512_mask_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutexvar_pd">_mm512_mask_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_permutexvar_ps">_mm512_mask_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rcp14_pd">_mm512_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rcp14_ps">_mm512_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_add_epi32">_mm512_mask_reduce_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_add_epi64">_mm512_mask_reduce_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_add_pd">_mm512_mask_reduce_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_add_ps">_mm512_mask_reduce_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_and_epi32">_mm512_mask_reduce_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by bitwise AND using mask k. Returns the bitwise AND of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_and_epi64">_mm512_mask_reduce_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_epi32">_mm512_mask_reduce_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_epi64">_mm512_mask_reduce_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_epu32">_mm512_mask_reduce_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_epu64">_mm512_mask_reduce_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_pd">_mm512_mask_reduce_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_max_ps">_mm512_mask_reduce_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_epi32">_mm512_mask_reduce_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_epi64">_mm512_mask_reduce_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_epu32">_mm512_mask_reduce_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_epu64">_mm512_mask_reduce_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_pd">_mm512_mask_reduce_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_min_ps">_mm512_mask_reduce_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_mul_epi32">_mm512_mask_reduce_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_mul_epi64">_mm512_mask_reduce_mul_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_mul_pd">_mm512_mask_reduce_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_mul_ps">_mm512_mask_reduce_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_or_epi32">_mm512_mask_reduce_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_reduce_or_epi64">_mm512_mask_reduce_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rol_epi32">_mm512_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rol_epi64">_mm512_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rolv_epi32">_mm512_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rolv_epi64">_mm512_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_ror_epi32">_mm512_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_ror_epi64">_mm512_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rorv_epi32">_mm512_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rorv_epi64">_mm512_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_roundscale_pd">_mm512_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_roundscale_ps">_mm512_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_roundscale_round_pd">_mm512_mask_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_roundscale_round_ps">_mm512_mask_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rsqrt14_pd">_mm512_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_rsqrt14_ps">_mm512_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_scalef_pd">_mm512_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_scalef_ps">_mm512_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_scalef_round_pd">_mm512_mask_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_scalef_round_ps">_mm512_mask_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_set1_epi32">_mm512_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_set1_epi64">_mm512_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_epi32">_mm512_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_f32x4">_mm512_mask_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_f64x2">_mm512_mask_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_i32x4">_mm512_mask_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_i64x2">_mm512_mask_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_pd">_mm512_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_shuffle_ps">_mm512_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sll_epi32">_mm512_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sll_epi64">_mm512_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_slli_epi32">_mm512_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_slli_epi64">_mm512_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sllv_epi32">_mm512_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sllv_epi64">_mm512_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sqrt_pd">_mm512_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sqrt_ps">_mm512_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sqrt_round_pd">_mm512_mask_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sqrt_round_ps">_mm512_mask_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sra_epi32">_mm512_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sra_epi64">_mm512_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srai_epi32">_mm512_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srai_epi64">_mm512_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srav_epi32">_mm512_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srav_epi64">_mm512_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srl_epi32">_mm512_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srl_epi64">_mm512_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srli_epi32">_mm512_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srli_epi64">_mm512_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srlv_epi32">_mm512_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_srlv_epi64">_mm512_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_store_epi32">_mm512_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_store_epi64">_mm512_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_store_pd">_mm512_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_store_ps">_mm512_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_storeu_epi32">_mm512_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_storeu_epi64">_mm512_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_storeu_pd">_mm512_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_storeu_ps">_mm512_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_epi32">_mm512_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_epi64">_mm512_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_pd">_mm512_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_ps">_mm512_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_round_pd">_mm512_mask_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_sub_round_ps">_mm512_mask_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_ternarylogic_epi32">_mm512_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_ternarylogic_epi64">_mm512_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_test_epi32_mask">_mm512_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_test_epi64_mask">_mm512_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_testn_epi32_mask">_mm512_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_testn_epi64_mask">_mm512_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpackhi_epi32">_mm512_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpackhi_epi64">_mm512_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpackhi_pd">_mm512_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpackhi_ps">_mm512_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpacklo_epi32">_mm512_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpacklo_epi64">_mm512_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpacklo_pd">_mm512_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_unpacklo_ps">_mm512_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_xor_epi32">_mm512_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mask_xor_epi64">_mm512_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_abs_epi32">_mm512_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the
unsigned results in <code>dst</code> using zeromask <code>k</code> (elements are zeroed out when
the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_abs_epi64">_mm512_maskz_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_epi32">_mm512_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_epi64">_mm512_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_pd">_mm512_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_ps">_mm512_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_round_pd">_mm512_maskz_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_add_round_ps">_mm512_maskz_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_alignr_epi32">_mm512_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and stores the low 64 bytes (16 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_alignr_epi64">_mm512_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and stores the low 64 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_and_epi32">_mm512_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_and_epi64">_mm512_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_andnot_epi32">_mm512_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_andnot_epi64">_mm512_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcast_f32x4">_mm512_maskz_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_f64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcast_f64x4">_mm512_maskz_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcast_i32x4">_mm512_maskz_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_i64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcast_i64x4">_mm512_maskz_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the 4 packed 64-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcastd_epi32">_mm512_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcastq_epi64">_mm512_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastsd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcastsd_pd">_mm512_maskz_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_broadcastss_ps">_mm512_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_compress_epi32">_mm512_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_compress_epi64">_mm512_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_compress_pd">_mm512_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_compress_ps">_mm512_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundepi32_ps">_mm512_maskz_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundepu32_ps">_mm512_maskz_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundpd_epi32">_mm512_maskz_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundpd_epu32">_mm512_maskz_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundpd_ps">_mm512_maskz_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundph_ps">_mm512_maskz_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundps_epi32">_mm512_maskz_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundps_epu32">_mm512_maskz_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundps_pd">_mm512_maskz_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvt_roundps_ph">_mm512_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi8_epi32">_mm512_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi8_epi64">_mm512_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi16_epi32">_mm512_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi16_epi64">_mm512_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi32_epi8">_mm512_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi32_epi16">_mm512_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi32_epi64">_mm512_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi32_pd">_mm512_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi32_ps">_mm512_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi64_epi8">_mm512_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi64_epi16">_mm512_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepi64_epi32">_mm512_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu8_epi32">_mm512_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu8_epi64">_mm512_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu16_epi32">_mm512_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu16_epi64">_mm512_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu32_epi64">_mm512_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu32_pd">_mm512_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtepu32_ps">_mm512_maskz_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtpd_epi32">_mm512_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtpd_epu32">_mm512_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtpd_ps">_mm512_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtph_ps">_mm512_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtps_epi32">_mm512_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtps_epu32">_mm512_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtps_pd">_mm512_maskz_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtps_ph">_mm512_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtsepi32_epi8">_mm512_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtsepi32_epi16">_mm512_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtsepi64_epi8">_mm512_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtsepi64_epi16">_mm512_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtsepi64_epi32">_mm512_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtt_roundpd_epi32">_mm512_maskz_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtt_roundpd_epu32">_mm512_maskz_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtt_roundps_epi32">_mm512_maskz_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtt_roundps_epu32">_mm512_maskz_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvttpd_epi32">_mm512_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvttpd_epu32">_mm512_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvttps_epi32">_mm512_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvttps_epu32">_mm512_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtusepi32_epi8">_mm512_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtusepi32_epi16">_mm512_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtusepi64_epi8">_mm512_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtusepi64_epi16">_mm512_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_cvtusepi64_epi32">_mm512_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_div_pd">_mm512_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_div_ps">_mm512_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_div_round_pd">_mm512_maskz_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_div_round_ps">_mm512_maskz_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expand_epi32">_mm512_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expand_epi64">_mm512_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expand_pd">_mm512_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expand_ps">_mm512_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expandloadu_epi32">_mm512_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expandloadu_epi64">_mm512_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expandloadu_pd">_mm512_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_expandloadu_ps">_mm512_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extractf32x4_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_extractf32x4_ps">_mm512_maskz_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extractf64x4_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_extractf64x4_pd">_mm512_maskz_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extracti32x4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_extracti32x4_epi32">_mm512_maskz_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extracti64x4_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_extracti64x4_epi64">_mm512_maskz_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fixupimm_pd">_mm512_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fixupimm_ps">_mm512_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fixupimm_round_pd">_mm512_maskz_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fixupimm_round_ps">_mm512_maskz_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmadd_pd">_mm512_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmadd_ps">_mm512_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmadd_round_pd">_mm512_maskz_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmadd_round_ps">_mm512_maskz_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in a using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmaddsub_pd">_mm512_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmaddsub_ps">_mm512_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmaddsub_round_pd">_mm512_maskz_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmaddsub_round_ps">_mm512_maskz_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsub_pd">_mm512_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsub_ps">_mm512_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsub_round_pd">_mm512_maskz_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsub_round_ps">_mm512_maskz_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsubadd_pd">_mm512_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsubadd_ps">_mm512_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsubadd_round_pd">_mm512_maskz_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fmsubadd_round_ps">_mm512_maskz_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmadd_pd">_mm512_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmadd_ps">_mm512_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmadd_round_pd">_mm512_maskz_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmadd_round_ps">_mm512_maskz_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmsub_pd">_mm512_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmsub_ps">_mm512_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmsub_round_pd">_mm512_maskz_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_fnmsub_round_ps">_mm512_maskz_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getexp_pd">_mm512_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getexp_ps">_mm512_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getexp_round_pd">_mm512_maskz_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getexp_round_ps">_mm512_maskz_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getmant_pd">_mm512_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getmant_ps">_mm512_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getmant_round_pd">_mm512_maskz_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_getmant_round_ps">_mm512_maskz_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_insertf32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_insertf32x4">_mm512_maskz_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_insertf64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_insertf64x4">_mm512_maskz_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_inserti32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_inserti32x4">_mm512_maskz_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_inserti64x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_inserti64x4">_mm512_maskz_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_load_epi32">_mm512_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_load_epi64">_mm512_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_load_pd">_mm512_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_load_ps">_mm512_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_loadu_epi32">_mm512_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_loadu_epi64">_mm512_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_loadu_pd">_mm512_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_loadu_ps">_mm512_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_epi32">_mm512_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_epi64">_mm512_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_epu32">_mm512_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_epu64">_mm512_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_pd">_mm512_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_ps">_mm512_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_round_pd">_mm512_maskz_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_max_round_ps">_mm512_maskz_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_epi32">_mm512_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_epi64">_mm512_maskz_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_epu32">_mm512_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_epu64">_mm512_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_pd">_mm512_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_ps">_mm512_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_round_pd">_mm512_maskz_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_min_round_ps">_mm512_maskz_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mov_epi32">_mm512_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mov_epi64">_mm512_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mov_pd">_mm512_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mov_ps">_mm512_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_movedup_pd">_mm512_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_movehdup_ps">_mm512_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_moveldup_ps">_mm512_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_epi32">_mm512_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_epu32">_mm512_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_pd">_mm512_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_ps">_mm512_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_round_pd">_mm512_maskz_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mul_round_ps">_mm512_maskz_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_mullo_epi32">_mm512_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_or_epi32">_mm512_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_or_epi64">_mm512_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permute_pd">_mm512_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permute_ps">_mm512_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutevar_pd">_mm512_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutevar_ps">_mm512_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex2var_epi32">_mm512_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex2var_epi64">_mm512_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex2var_pd">_mm512_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex2var_ps">_mm512_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex_epi64">_mm512_maskz_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutex_pd">_mm512_maskz_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutexvar_epi32">_mm512_maskz_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutexvar_epi64">_mm512_maskz_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutexvar_pd">_mm512_maskz_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_permutexvar_ps">_mm512_maskz_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rcp14_pd">_mm512_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rcp14_ps">_mm512_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rol_epi32">_mm512_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rol_epi64">_mm512_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rolv_epi32">_mm512_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rolv_epi64">_mm512_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_ror_epi32">_mm512_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_ror_epi64">_mm512_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rorv_epi32">_mm512_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rorv_epi64">_mm512_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_roundscale_pd">_mm512_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_roundscale_ps">_mm512_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_roundscale_round_pd">_mm512_maskz_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_roundscale_round_ps">_mm512_maskz_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rsqrt14_pd">_mm512_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_rsqrt14_ps">_mm512_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_scalef_pd">_mm512_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_scalef_ps">_mm512_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_scalef_round_pd">_mm512_maskz_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_scalef_round_ps">_mm512_maskz_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_set1_epi32">_mm512_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_set1_epi64">_mm512_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_epi32">_mm512_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_f32x4">_mm512_maskz_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_f64x2">_mm512_maskz_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_i32x4">_mm512_maskz_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_i64x2">_mm512_maskz_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_pd">_mm512_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_shuffle_ps">_mm512_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sll_epi32">_mm512_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sll_epi64">_mm512_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_slli_epi32">_mm512_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_slli_epi64">_mm512_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sllv_epi32">_mm512_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sllv_epi64">_mm512_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sqrt_pd">_mm512_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sqrt_ps">_mm512_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sqrt_round_pd">_mm512_maskz_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sqrt_round_ps">_mm512_maskz_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sra_epi32">_mm512_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sra_epi64">_mm512_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srai_epi32">_mm512_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srai_epi64">_mm512_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srav_epi32">_mm512_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srav_epi64">_mm512_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srl_epi32">_mm512_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srl_epi64">_mm512_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srli_epi32">_mm512_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srli_epi64">_mm512_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srlv_epi32">_mm512_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_srlv_epi64">_mm512_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_epi32">_mm512_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_epi64">_mm512_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_pd">_mm512_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_ps">_mm512_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_round_pd">_mm512_maskz_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_sub_round_ps">_mm512_maskz_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_ternarylogic_epi32">_mm512_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_ternarylogic_epi64">_mm512_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpackhi_epi32">_mm512_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpackhi_epi64">_mm512_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpackhi_pd">_mm512_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpackhi_ps">_mm512_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpacklo_epi32">_mm512_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpacklo_epi64">_mm512_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpacklo_pd">_mm512_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_unpacklo_ps">_mm512_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_xor_epi32">_mm512_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_maskz_xor_epi64">_mm512_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_max_epi32">_mm512_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_max_epi64">_mm512_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_max_epu32">_mm512_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_max_epu64">_mm512_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_max_pd">_mm512_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_max_ps">_mm512_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_max_round_pd">_mm512_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_max_round_ps">_mm512_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_min_epi32">_mm512_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_min_epi64">_mm512_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_min_epu32">_mm512_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_min_epu64">_mm512_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_min_pd">_mm512_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.
Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_min_ps">_mm512_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_min_round_pd">_mm512_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_min_round_ps">_mm512_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_movedup_pd">_mm512_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_movehdup_ps">_mm512_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_moveldup_ps">_mm512_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_epi32">_mm512_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_epu32">_mm512_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_pd">_mm512_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_ps">_mm512_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_round_pd">_mm512_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_mul_round_ps">_mm512_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_mullo_epi32">_mm512_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mullox_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_mullox_epi64">_mm512_mullox_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_or_epi32">_mm512_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_or_epi64">_mm512_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_or_si512">_mm512_or_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise OR of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_permute_pd">_mm512_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_permute_ps">_mm512_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_permutevar_epi32">_mm512_permutevar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst. Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_permutexvar_epi32, and it is recommended that you use that intrinsic name.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_permutevar_pd">_mm512_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_permutevar_ps">_mm512_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex2var_epi32">_mm512_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex2var_epi64">_mm512_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex2var_pd">_mm512_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex2var_ps">_mm512_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex_epi64">_mm512_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_permutex_pd">_mm512_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_permutexvar_epi32">_mm512_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_permutexvar_epi64">_mm512_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_permutexvar_pd">_mm512_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_permutexvar_ps">_mm512_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_rcp14_pd">_mm512_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_rcp14_ps">_mm512_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_add_epi32">_mm512_reduce_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by addition. Returns the sum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_add_epi64">_mm512_reduce_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by addition. Returns the sum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_add_pd">_mm512_reduce_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_add_ps">_mm512_reduce_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_and_epi32">_mm512_reduce_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_and_epi64">_mm512_reduce_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_epi32">_mm512_reduce_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 32-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_epi64">_mm512_reduce_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 64-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_epu32">_mm512_reduce_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 32-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_epu64">_mm512_reduce_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 64-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_pd">_mm512_reduce_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_max_ps">_mm512_reduce_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_epi32">_mm512_reduce_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 32-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_epi64">_mm512_reduce_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed signed 64-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_epu32">_mm512_reduce_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 32-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_epu64">_mm512_reduce_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed unsigned 64-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_pd">_mm512_reduce_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_min_ps">_mm512_reduce_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_mul_epi32">_mm512_reduce_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by multiplication. Returns the product of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_mul_epi64">_mm512_reduce_mul_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by multiplication. Returns the product of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_mul_pd">_mm512_reduce_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_mul_ps">_mm512_reduce_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_or_epi32">_mm512_reduce_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 32-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_reduce_or_epi64">_mm512_reduce_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Reduce the packed 64-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_rol_epi32">_mm512_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_rol_epi64">_mm512_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_rolv_epi32">_mm512_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_rolv_epi64">_mm512_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_ror_epi32">_mm512_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_ror_epi64">_mm512_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_rorv_epi32">_mm512_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_rorv_epi64">_mm512_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_roundscale_pd">_mm512_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_roundscale_ps">_mm512_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_roundscale_round_pd">_mm512_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_roundscale_round_ps">_mm512_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_rsqrt14_pd">_mm512_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_rsqrt14_ps">_mm512_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_scalef_pd">_mm512_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_scalef_ps">_mm512_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_scalef_round_pd">_mm512_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_scalef_round_ps">_mm512_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_epi8">_mm512_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 8-bit integer a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_epi16">_mm512_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast the low packed 16-bit integer from a to all elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_epi32">_mm512_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_epi64">_mm512_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_pd">_mm512_set1_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_set1_ps">_mm512_set1_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Broadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_set4_epi32">_mm512_set4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 32-bit integers in dst with the repeated 4 element sequence.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_set4_epi64">_mm512_set4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 64-bit integers in dst with the repeated 4 element sequence.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_set4_pd">_mm512_set4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_set4_ps">_mm512_set4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi8.html" title="fn core::core_arch::x86::avx512f::_mm512_set_epi8">_mm512_set_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 8-bit integers in dst with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi16.html" title="fn core::core_arch::x86::avx512f::_mm512_set_epi16">_mm512_set_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 16-bit integers in dst with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_set_epi32">_mm512_set_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sets packed 32-bit integers in <code>dst</code> with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_set_epi64">_mm512_set_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 64-bit integers in dst with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_set_pd">_mm512_set_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed double-precision (64-bit) floating-point elements in dst with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_set_ps">_mm512_set_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sets packed 32-bit integers in <code>dst</code> with the supplied values.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_setr4_epi32">_mm512_setr4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 32-bit integers in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_setr4_epi64">_mm512_setr4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 64-bit integers in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_setr4_pd">_mm512_setr4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_setr4_ps">_mm512_setr4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_setr_epi32">_mm512_setr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sets packed 32-bit integers in <code>dst</code> with the supplied values in reverse
order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_setr_epi64">_mm512_setr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed 64-bit integers in dst with the supplied values in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_setr_pd">_mm512_setr_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Set packed double-precision (64-bit) floating-point elements in dst with the supplied values in reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_setr_ps">_mm512_setr_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Sets packed 32-bit integers in <code>dst</code> with the supplied values in
reverse order.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero.html" title="fn core::core_arch::x86::avx512f::_mm512_setzero">_mm512_setzero</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Return vector of type __m512 with all elements set to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_setzero_epi32">_mm512_setzero_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Return vector of type __m512i with all elements set to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_setzero_pd">_mm512_setzero_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Returns vector of type <code>__m512d</code> with all elements set to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_setzero_ps">_mm512_setzero_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Returns vector of type <code>__m512d</code> with all elements set to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_setzero_si512">_mm512_setzero_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Returns vector of type <code>__m512i</code> with all elements set to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_epi32">_mm512_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_f32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_f32x4">_mm512_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_f64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_f64x2">_mm512_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_i32x4.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_i32x4">_mm512_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_i64x2.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_i64x2">_mm512_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_pd">_mm512_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_shuffle_ps">_mm512_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_sll_epi32">_mm512_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_sll_epi64">_mm512_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_slli_epi32">_mm512_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_slli_epi64">_mm512_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_sllv_epi32">_mm512_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_sllv_epi64">_mm512_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_sqrt_pd">_mm512_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_sqrt_ps">_mm512_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_sqrt_round_pd">_mm512_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_sqrt_round_ps">_mm512_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_sra_epi32">_mm512_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_sra_epi64">_mm512_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_srai_epi32">_mm512_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_srai_epi64">_mm512_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_srav_epi32">_mm512_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_srav_epi64">_mm512_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_srl_epi32">_mm512_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_srl_epi64">_mm512_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_srli_epi32">_mm512_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_srli_epi64">_mm512_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_srlv_epi32">_mm512_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_srlv_epi64">_mm512_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_store_epi32">_mm512_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_store_epi64">_mm512_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_store_pd">_mm512_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_store_ps">_mm512_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_store_si512">_mm512_store_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_storeu_epi32">_mm512_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_storeu_epi64">_mm512_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_storeu_pd">_mm512_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Stores 512-bits (composed of 8 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_storeu_si512">_mm512_storeu_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits of integer data from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_stream_pd">_mm512_stream_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_stream_ps">_mm512_stream_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_stream_si512">_mm512_stream_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Store 512-bits of integer data from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_epi32">_mm512_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_epi64">_mm512_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_pd">_mm512_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_ps">_mm512_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_round_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_round_pd">_mm512_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_round_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_sub_round_ps">_mm512_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_ternarylogic_epi32">_mm512_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_ternarylogic_epi64">_mm512_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_test_epi32_mask">_mm512_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_test_epi64_mask">_mm512_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_testn_epi32_mask">_mm512_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm512_testn_epi64_mask">_mm512_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined.html" title="fn core::core_arch::x86::avx512f::_mm512_undefined">_mm512_undefined</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Return vector of type __m512 with indeterminate elements.
Despite being “undefined”, this is some valid value and not equivalent to <a href="../../../mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit"><code>mem::MaybeUninit</code></a>.
In practice, this is equivalent to <a href="../../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_undefined_epi32">_mm512_undefined_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Return vector of type __m512i with indeterminate elements.
Despite being “undefined”, this is some valid value and not equivalent to <a href="../../../mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit"><code>mem::MaybeUninit</code></a>.
In practice, this is equivalent to <a href="../../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_undefined_pd">_mm512_undefined_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Returns vector of type <code>__m512d</code> with indeterminate elements.
Despite being “undefined”, this is some valid value and not equivalent to <a href="../../../mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit"><code>mem::MaybeUninit</code></a>.
In practice, this is equivalent to <a href="../../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_undefined_ps">_mm512_undefined_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Returns vector of type <code>__m512</code> with indeterminate elements.
Despite being “undefined”, this is some valid value and not equivalent to <a href="../../../mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit"><code>mem::MaybeUninit</code></a>.
In practice, this is equivalent to <a href="../../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_unpackhi_epi32">_mm512_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_unpackhi_epi64">_mm512_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_unpackhi_pd">_mm512_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_unpackhi_ps">_mm512_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_unpacklo_epi32">_mm512_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_unpacklo_epi64">_mm512_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm512_unpacklo_pd">_mm512_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_unpacklo_ps">_mm512_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm512_xor_epi32">_mm512_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm512_xor_epi64">_mm512_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_xor_si512">_mm512_xor_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextpd128_pd512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextpd128_pd512">_mm512_zextpd128_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextpd256_pd512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextpd256_pd512">_mm512_zextpd256_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextps128_ps512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextps128_ps512">_mm512_zextps128_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128 to type __m512; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextps256_ps512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextps256_ps512">_mm512_zextps256_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256 to type __m512; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextsi128_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextsi128_si512">_mm512_zextsi128_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextsi256_si512.html" title="fn core::core_arch::x86::avx512f::_mm512_zextsi256_si512">_mm512_zextsi256_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_add_round_sd">_mm_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_add_round_ss">_mm_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_alignr_epi32">_mm_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_alignr_epi64">_mm_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_epi32_mask">_mm_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_epi64_mask">_mm_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_epu32_mask">_mm_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_epu64_mask">_mm_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_pd_mask">_mm_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_ps_mask">_mm_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_round_sd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_round_sd_mask">_mm_cmp_round_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_round_ss_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_round_ss_mask">_mm_cmp_round_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_sd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_sd_mask">_mm_cmp_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ss_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmp_ss_mask">_mm_cmp_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpeq_epi32_mask">_mm_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpeq_epi64_mask">_mm_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpeq_epu32_mask">_mm_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpeq_epu64_mask">_mm_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpge_epi32_mask">_mm_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpge_epi64_mask">_mm_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpge_epu32_mask">_mm_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpge_epu64_mask">_mm_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpgt_epi32_mask">_mm_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpgt_epi64_mask">_mm_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpgt_epu32_mask">_mm_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpgt_epu64_mask">_mm_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmple_epi32_mask">_mm_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmple_epi64_mask">_mm_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmple_epu32_mask">_mm_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmple_epu64_mask">_mm_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmplt_epi32_mask">_mm_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmplt_epi64_mask">_mm_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmplt_epu32_mask">_mm_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmplt_epu64_mask">_mm_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpneq_epi32_mask">_mm_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpneq_epi64_mask">_mm_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpneq_epu32_mask">_mm_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_cmpneq_epu64_mask">_mm_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comi_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_comi_round_sd">_mm_comi_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comi_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_comi_round_ss">_mm_comi_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundi32_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundi32_ss">_mm_cvt_roundi32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundsd_i32">_mm_cvt_roundsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_si32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundsd_si32">_mm_cvt_roundsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundsd_ss">_mm_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundsd_u32">_mm_cvt_roundsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsi32_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundsi32_ss">_mm_cvt_roundsi32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundss_i32">_mm_cvt_roundss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_sd.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundss_sd">_mm_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_si32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundss_si32">_mm_cvt_roundss_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundss_u32">_mm_cvt_roundss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundu32_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvt_roundu32_ss">_mm_cvt_roundu32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepi32_epi8">_mm_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepi32_epi16">_mm_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepi64_epi8">_mm_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepi64_epi16">_mm_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepi64_epi32">_mm_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm_cvtepu32_pd">_mm_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti32_sd.html" title="fn core::core_arch::x86::avx512f::_mm_cvti32_sd">_mm_cvti32_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the signed 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti32_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvti32_ss">_mm_cvti32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtpd_epu32">_mm_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtps_epu32">_mm_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsd_i32">_mm_cvtsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsd_u32">_mm_cvtsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsepi32_epi8">_mm_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsepi32_epi16">_mm_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsepi64_epi8">_mm_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsepi64_epi16">_mm_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtsepi64_epi32">_mm_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtss_i32">_mm_cvtss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtss_u32">_mm_cvtss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundsd_i32">_mm_cvtt_roundsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_si32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundsd_si32">_mm_cvtt_roundsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundsd_u32">_mm_cvtt_roundsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundss_i32">_mm_cvtt_roundss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_si32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundss_si32">_mm_cvtt_roundss_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtt_roundss_u32">_mm_cvtt_roundss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttpd_epu32">_mm_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttps_epu32">_mm_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttsd_i32">_mm_cvttsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttsd_u32">_mm_cvttsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_i32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttss_i32">_mm_cvttss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_u32.html" title="fn core::core_arch::x86::avx512f::_mm_cvttss_u32">_mm_cvttss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu32_sd.html" title="fn core::core_arch::x86::avx512f::_mm_cvtu32_sd">_mm_cvtu32_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the unsigned 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu32_ss.html" title="fn core::core_arch::x86::avx512f::_mm_cvtu32_ss">_mm_cvtu32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtusepi32_epi8">_mm_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtusepi32_epi16">_mm_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_cvtusepi64_epi8">_mm_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_cvtusepi64_epi16">_mm_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_cvtusepi64_epi32">_mm_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_div_round_sd">_mm_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_div_round_ss">_mm_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_pd">_mm_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_ps">_mm_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_round_sd">_mm_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_round_ss">_mm_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_sd">_mm_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fixupimm_ss">_mm_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fmadd_round_sd">_mm_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fmadd_round_ss">_mm_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fmsub_round_sd">_mm_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fmsub_round_ss">_mm_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fnmadd_round_sd">_mm_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fnmadd_round_ss">_mm_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_fnmsub_round_sd">_mm_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_fnmsub_round_ss">_mm_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_pd">_mm_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_ps">_mm_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_round_sd">_mm_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_round_ss">_mm_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_sd.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_sd">_mm_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_ss.html" title="fn core::core_arch::x86::avx512f::_mm_getexp_ss">_mm_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_pd">_mm_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_ps">_mm_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_round_sd">_mm_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_round_ss">_mm_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_sd.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_sd">_mm_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_ss.html" title="fn core::core_arch::x86::avx512f::_mm_getmant_ss">_mm_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_load_epi32">_mm_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_load_epi64">_mm_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_loadu_epi32">_mm_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_loadu_epi64">_mm_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask2_permutex2var_epi32">_mm_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask2_permutex2var_epi64">_mm_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask2_permutex2var_pd">_mm_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask2_permutex2var_ps">_mm_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_pd">_mm_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_ps">_mm_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_round_sd">_mm_mask3_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_round_ss">_mm_mask3_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_sd">_mm_mask3_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmadd_ss">_mm_mask3_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmaddsub_pd">_mm_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmaddsub_ps">_mm_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_pd">_mm_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_ps">_mm_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_round_sd">_mm_mask3_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_round_ss">_mm_mask3_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_sd">_mm_mask3_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsub_ss">_mm_mask3_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsubadd_pd">_mm_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fmsubadd_ps">_mm_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_pd">_mm_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_ps">_mm_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_round_sd">_mm_mask3_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_round_ss">_mm_mask3_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_sd">_mm_mask3_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmadd_ss">_mm_mask3_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_pd">_mm_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_ps">_mm_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_round_sd">_mm_mask3_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_round_ss">_mm_mask3_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_sd">_mm_mask3_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask3_fnmsub_ss">_mm_mask3_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_abs_epi32">_mm_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_epi32">_mm_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_epi64">_mm_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_pd">_mm_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_ps">_mm_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_round_sd">_mm_mask_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_round_ss">_mm_mask_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_sd">_mm_mask_add_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_add_ss">_mm_mask_add_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_alignr_epi32">_mm_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_alignr_epi64">_mm_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_and_epi32">_mm_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_and_epi64">_mm_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_andnot_epi32">_mm_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_andnot_epi64">_mm_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_blend_epi32">_mm_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_blend_epi64">_mm_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_blend_pd">_mm_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_blend_ps">_mm_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_broadcastd_epi32">_mm_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_broadcastq_epi64">_mm_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_broadcastss_ps">_mm_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_epi32_mask">_mm_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_epi64_mask">_mm_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_epu32_mask">_mm_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_epu64_mask">_mm_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_pd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_pd_mask">_mm_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_ps_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_ps_mask">_mm_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_round_sd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_round_sd_mask">_mm_mask_cmp_round_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_round_ss_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_round_ss_mask">_mm_mask_cmp_round_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not seti).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_sd_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_sd_mask">_mm_mask_cmp_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_ss_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmp_ss_mask">_mm_mask_cmp_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpeq_epi32_mask">_mm_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpeq_epi64_mask">_mm_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpeq_epu32_mask">_mm_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpeq_epu64_mask">_mm_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpge_epi32_mask">_mm_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpge_epi64_mask">_mm_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpge_epu32_mask">_mm_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpge_epu64_mask">_mm_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpgt_epi32_mask">_mm_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpgt_epi64_mask">_mm_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpgt_epu32_mask">_mm_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpgt_epu64_mask">_mm_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmple_epi32_mask">_mm_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmple_epi64_mask">_mm_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmple_epu32_mask">_mm_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmple_epu64_mask">_mm_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmplt_epi32_mask">_mm_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmplt_epi64_mask">_mm_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmplt_epu32_mask">_mm_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmplt_epu64_mask">_mm_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpneq_epi32_mask">_mm_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpneq_epi64_mask">_mm_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpneq_epu32_mask">_mm_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cmpneq_epu64_mask">_mm_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compress_epi32">_mm_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compress_epi64">_mm_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compress_pd">_mm_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compress_ps">_mm_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compressstoreu_epi32">_mm_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compressstoreu_epi64">_mm_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compressstoreu_pd">_mm_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_compressstoreu_ps">_mm_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvt_roundps_ph">_mm_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundsd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvt_roundsd_ss">_mm_mask_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundss_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvt_roundss_sd">_mm_mask_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi8_epi32">_mm_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi8_epi64">_mm_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi16_epi32">_mm_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi16_epi64">_mm_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_epi8">_mm_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_epi16">_mm_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_epi64">_mm_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_pd">_mm_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_ps">_mm_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_storeu_epi8">_mm_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi32_storeu_epi16">_mm_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_epi8">_mm_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_epi16">_mm_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_epi32">_mm_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_storeu_epi8">_mm_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_storeu_epi16">_mm_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepi64_storeu_epi32">_mm_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu8_epi32">_mm_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu8_epi64">_mm_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu16_epi32">_mm_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu16_epi64">_mm_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu32_epi64">_mm_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtepu32_pd">_mm_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtpd_epi32">_mm_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtpd_epu32">_mm_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtpd_ps">_mm_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtph_ps">_mm_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtps_epi32">_mm_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtps_epu32">_mm_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtps_ph">_mm_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsd_ss">_mm_mask_cvtsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi32_epi8">_mm_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi32_epi16">_mm_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi32_storeu_epi8">_mm_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi32_storeu_epi16">_mm_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_epi8">_mm_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_epi16">_mm_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_epi32">_mm_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_storeu_epi8">_mm_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_storeu_epi16">_mm_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtsepi64_storeu_epi32">_mm_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtss_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtss_sd">_mm_mask_cvtss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvttpd_epi32">_mm_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvttpd_epu32">_mm_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvttps_epi32">_mm_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvttps_epu32">_mm_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi32_epi8">_mm_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi32_epi16">_mm_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi32_storeu_epi8">_mm_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi32_storeu_epi16">_mm_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_epi8">_mm_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_epi16">_mm_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_epi32">_mm_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_storeu_epi8">_mm_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_storeu_epi16">_mm_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_cvtusepi64_storeu_epi32">_mm_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_pd">_mm_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_ps">_mm_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_round_sd">_mm_mask_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_round_ss">_mm_mask_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_sd">_mm_mask_div_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_div_ss">_mm_mask_div_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expand_epi32">_mm_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expand_epi64">_mm_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expand_pd">_mm_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expand_ps">_mm_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expandloadu_epi32">_mm_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expandloadu_epi64">_mm_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expandloadu_pd">_mm_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_expandloadu_ps">_mm_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_pd">_mm_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_ps">_mm_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_round_sd">_mm_mask_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_round_ss">_mm_mask_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_sd">_mm_mask_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fixupimm_ss">_mm_mask_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_pd">_mm_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_ps">_mm_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_round_sd">_mm_mask_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_round_ss">_mm_mask_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_sd">_mm_mask_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmadd_ss">_mm_mask_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmaddsub_pd">_mm_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmaddsub_ps">_mm_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_pd">_mm_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_ps">_mm_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_round_sd">_mm_mask_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_round_ss">_mm_mask_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_sd">_mm_mask_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsub_ss">_mm_mask_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsubadd_pd">_mm_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fmsubadd_ps">_mm_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_pd">_mm_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_ps">_mm_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_round_sd">_mm_mask_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_round_ss">_mm_mask_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_sd">_mm_mask_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmadd_ss">_mm_mask_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_pd">_mm_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_ps">_mm_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_round_sd">_mm_mask_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_round_ss">_mm_mask_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_sd">_mm_mask_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_fnmsub_ss">_mm_mask_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_pd">_mm_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_ps">_mm_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_round_sd">_mm_mask_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_round_ss">_mm_mask_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_sd">_mm_mask_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getexp_ss">_mm_mask_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_pd">_mm_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_ps">_mm_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_round_sd">_mm_mask_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_round_ss">_mm_mask_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_sd">_mm_mask_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_getmant_ss">_mm_mask_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_load_epi32">_mm_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_load_epi64">_mm_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_load_pd">_mm_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_load_ps">_mm_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_loadu_epi32">_mm_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_loadu_epi64">_mm_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_loadu_pd">_mm_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_loadu_ps">_mm_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_epi32">_mm_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_epi64">_mm_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_epu32">_mm_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_epu64">_mm_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_pd">_mm_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_ps">_mm_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_round_sd">_mm_mask_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_round_ss">_mm_mask_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_sd">_mm_mask_max_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_max_ss">_mm_mask_max_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_epi32">_mm_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_epu32">_mm_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_epu64">_mm_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_pd">_mm_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_ps">_mm_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_round_sd">_mm_mask_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_round_ss">_mm_mask_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_sd">_mm_mask_min_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_min_ss">_mm_mask_min_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mov_epi32">_mm_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mov_epi64">_mm_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mov_pd">_mm_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mov_ps">_mm_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_move_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_move_sd">_mm_mask_move_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_move_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_move_ss">_mm_mask_move_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_movedup_pd">_mm_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_movehdup_ps">_mm_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_moveldup_ps">_mm_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_epi32">_mm_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_epu32">_mm_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_pd">_mm_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_ps">_mm_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_round_sd">_mm_mask_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_round_ss">_mm_mask_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_sd">_mm_mask_mul_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mul_ss">_mm_mask_mul_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_mullo_epi32">_mm_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_or_epi32">_mm_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_or_epi64">_mm_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permute_pd">_mm_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permute_ps">_mm_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutevar_pd">_mm_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutevar_ps">_mm_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutex2var_epi32">_mm_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutex2var_epi64">_mm_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutex2var_pd">_mm_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_permutex2var_ps">_mm_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rcp14_pd">_mm_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rcp14_ps">_mm_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rcp14_sd">_mm_mask_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rcp14_ss">_mm_mask_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rol_epi32">_mm_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rol_epi64">_mm_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rolv_epi32">_mm_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rolv_epi64">_mm_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_ror_epi32">_mm_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_ror_epi64">_mm_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rorv_epi32">_mm_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rorv_epi64">_mm_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_pd">_mm_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_ps">_mm_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_round_sd">_mm_mask_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_round_ss">_mm_mask_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_sd">_mm_mask_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_roundscale_ss">_mm_mask_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rsqrt14_pd">_mm_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rsqrt14_ps">_mm_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rsqrt14_sd">_mm_mask_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_rsqrt14_ss">_mm_mask_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_pd">_mm_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_ps">_mm_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_round_sd">_mm_mask_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_round_ss">_mm_mask_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_sd">_mm_mask_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_scalef_ss">_mm_mask_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_set1_epi32">_mm_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_set1_epi64">_mm_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_shuffle_epi32">_mm_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_shuffle_pd">_mm_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_shuffle_ps">_mm_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sll_epi32">_mm_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sll_epi64">_mm_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_slli_epi32">_mm_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_slli_epi64">_mm_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sllv_epi32">_mm_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sllv_epi64">_mm_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_pd">_mm_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_ps">_mm_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_round_sd">_mm_mask_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_round_ss">_mm_mask_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_sd">_mm_mask_sqrt_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sqrt_ss">_mm_mask_sqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sra_epi32">_mm_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sra_epi64">_mm_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srai_epi32">_mm_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srai_epi64">_mm_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srav_epi32">_mm_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srav_epi64">_mm_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srl_epi32">_mm_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srl_epi64">_mm_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srli_epi32">_mm_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srli_epi64">_mm_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srlv_epi32">_mm_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_srlv_epi64">_mm_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_store_epi32">_mm_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_store_epi64">_mm_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_store_pd">_mm_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_store_ps">_mm_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_storeu_epi32">_mm_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_storeu_epi64">_mm_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_storeu_pd">_mm_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_storeu_ps">_mm_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_epi32">_mm_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_epi64">_mm_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_pd">_mm_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_ps">_mm_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_round_sd">_mm_mask_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_round_ss">_mm_mask_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_sd">_mm_mask_sub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mask_sub_ss">_mm_mask_sub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_ternarylogic_epi32">_mm_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_ternarylogic_epi64">_mm_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_test_epi32_mask">_mm_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_test_epi64_mask">_mm_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_testn_epi32_mask">_mm_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_mask_testn_epi64_mask">_mm_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpackhi_epi32">_mm_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpackhi_epi64">_mm_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpackhi_pd">_mm_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpackhi_ps">_mm_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpacklo_epi32">_mm_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpacklo_epi64">_mm_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpacklo_pd">_mm_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm_mask_unpacklo_ps">_mm_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_mask_xor_epi32">_mm_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_mask_xor_epi64">_mm_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_abs_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_abs_epi32">_mm_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_epi32">_mm_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_epi64">_mm_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_pd">_mm_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_ps">_mm_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_round_sd">_mm_maskz_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_round_ss">_mm_maskz_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_sd">_mm_maskz_add_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_add_ss">_mm_maskz_add_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_alignr_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_alignr_epi32">_mm_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_alignr_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_alignr_epi64">_mm_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_and_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_and_epi32">_mm_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_and_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_and_epi64">_mm_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_andnot_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_andnot_epi32">_mm_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_andnot_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_andnot_epi64">_mm_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_broadcastd_epi32">_mm_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastq_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_broadcastq_epi64">_mm_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastss_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_broadcastss_ps">_mm_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_compress_epi32">_mm_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_compress_epi64">_mm_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_compress_pd">_mm_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_compress_ps">_mm_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundps_ph.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvt_roundps_ph">_mm_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundsd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvt_roundsd_ss">_mm_maskz_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundss_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvt_roundss_sd">_mm_maskz_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi8_epi32">_mm_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi8_epi64">_mm_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi16_epi32">_mm_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi16_epi64">_mm_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi32_epi8">_mm_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi32_epi16">_mm_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi32_epi64">_mm_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi32_pd">_mm_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi32_ps">_mm_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi64_epi8">_mm_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi64_epi16">_mm_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepi64_epi32">_mm_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu8_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu8_epi32">_mm_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in th elow 4 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu8_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu8_epi64">_mm_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu16_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu16_epi32">_mm_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu16_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu16_epi64">_mm_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu32_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu32_epi64">_mm_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu32_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtepu32_pd">_mm_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtpd_epi32">_mm_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtpd_epu32">_mm_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtpd_ps">_mm_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtph_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtph_ps">_mm_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtps_epi32">_mm_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtps_epu32">_mm_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_ph.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtps_ph">_mm_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsd_ss">_mm_maskz_cvtsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsepi32_epi8">_mm_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsepi32_epi16">_mm_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsepi64_epi8">_mm_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsepi64_epi16">_mm_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtsepi64_epi32">_mm_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtss_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtss_sd">_mm_maskz_cvtss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttpd_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvttpd_epi32">_mm_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttpd_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvttpd_epu32">_mm_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttps_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvttps_epi32">_mm_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttps_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvttps_epu32">_mm_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtusepi32_epi8">_mm_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtusepi32_epi16">_mm_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi8.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtusepi64_epi8">_mm_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi16.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtusepi64_epi16">_mm_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_cvtusepi64_epi32">_mm_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_pd">_mm_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_ps">_mm_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_round_sd">_mm_maskz_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_round_ss">_mm_maskz_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_sd">_mm_maskz_div_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_div_ss">_mm_maskz_div_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expand_epi32">_mm_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expand_epi64">_mm_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expand_pd">_mm_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expand_ps">_mm_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expandloadu_epi32">_mm_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expandloadu_epi64">_mm_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expandloadu_pd">_mm_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_expandloadu_ps">_mm_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_pd">_mm_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_ps">_mm_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_round_sd">_mm_maskz_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_round_ss">_mm_maskz_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_sd">_mm_maskz_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fixupimm_ss">_mm_maskz_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_pd">_mm_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_ps">_mm_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_round_sd">_mm_maskz_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_round_ss">_mm_maskz_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_sd">_mm_maskz_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmadd_ss">_mm_maskz_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmaddsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmaddsub_pd">_mm_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmaddsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmaddsub_ps">_mm_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_pd">_mm_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_ps">_mm_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_round_sd">_mm_maskz_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_round_ss">_mm_maskz_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_sd">_mm_maskz_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsub_ss">_mm_maskz_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsubadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsubadd_pd">_mm_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsubadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fmsubadd_ps">_mm_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_pd">_mm_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_ps">_mm_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_round_sd">_mm_maskz_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_round_ss">_mm_maskz_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_sd">_mm_maskz_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmadd_ss">_mm_maskz_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_pd">_mm_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_ps">_mm_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_round_sd">_mm_maskz_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_round_ss">_mm_maskz_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_sd">_mm_maskz_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_fnmsub_ss">_mm_maskz_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_pd">_mm_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_ps">_mm_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_round_sd">_mm_maskz_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_round_ss">_mm_maskz_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_sd">_mm_maskz_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getexp_ss">_mm_maskz_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_pd">_mm_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_ps">_mm_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_round_sd">_mm_maskz_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_round_ss">_mm_maskz_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_sd">_mm_maskz_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_getmant_ss">_mm_maskz_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_load_epi32">_mm_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_load_epi64">_mm_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_load_pd">_mm_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_load_ps">_mm_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_loadu_epi32">_mm_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_loadu_epi64">_mm_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_loadu_pd">_mm_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_loadu_ps">_mm_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_epi32">_mm_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_epi64">_mm_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_epu32">_mm_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_epu64">_mm_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_pd">_mm_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_ps">_mm_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_round_sd">_mm_maskz_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_round_ss">_mm_maskz_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_sd">_mm_maskz_max_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_max_ss">_mm_maskz_max_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_epi32">_mm_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_epu32">_mm_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_epu64">_mm_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_pd">_mm_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_ps">_mm_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_round_sd">_mm_maskz_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_round_ss">_mm_maskz_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_sd">_mm_maskz_min_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_min_ss">_mm_maskz_min_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mov_epi32">_mm_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mov_epi64">_mm_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mov_pd">_mm_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mov_ps">_mm_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_move_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_move_sd">_mm_maskz_move_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_move_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_move_ss">_mm_maskz_move_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_movedup_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_movedup_pd">_mm_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_movehdup_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_movehdup_ps">_mm_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_moveldup_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_moveldup_ps">_mm_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_epi32">_mm_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_epu32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_epu32">_mm_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_pd">_mm_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_ps">_mm_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_round_sd">_mm_maskz_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_round_ss">_mm_maskz_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_sd">_mm_maskz_mul_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mul_ss">_mm_maskz_mul_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mullo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_mullo_epi32">_mm_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_or_epi32">_mm_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_or_epi64">_mm_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permute_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permute_pd">_mm_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permute_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permute_ps">_mm_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutevar_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutevar_pd">_mm_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutevar_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutevar_ps">_mm_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutex2var_epi32">_mm_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutex2var_epi64">_mm_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutex2var_pd">_mm_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_permutex2var_ps">_mm_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rcp14_pd">_mm_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rcp14_ps">_mm_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rcp14_sd">_mm_maskz_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rcp14_ss">_mm_maskz_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rol_epi32">_mm_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rol_epi64">_mm_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rolv_epi32">_mm_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rolv_epi64">_mm_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_ror_epi32">_mm_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_ror_epi64">_mm_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rorv_epi32">_mm_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rorv_epi64">_mm_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_pd">_mm_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_ps">_mm_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_round_sd">_mm_maskz_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_round_ss">_mm_maskz_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_sd">_mm_maskz_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_roundscale_ss">_mm_maskz_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rsqrt14_pd">_mm_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rsqrt14_ps">_mm_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rsqrt14_sd">_mm_maskz_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_rsqrt14_ss">_mm_maskz_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_pd">_mm_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_ps">_mm_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_round_sd">_mm_maskz_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_round_ss">_mm_maskz_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_sd">_mm_maskz_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_scalef_ss">_mm_maskz_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_set1_epi32">_mm_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_set1_epi64">_mm_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_shuffle_epi32">_mm_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_shuffle_pd">_mm_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_shuffle_ps">_mm_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sll_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sll_epi32">_mm_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sll_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sll_epi64">_mm_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_slli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_slli_epi32">_mm_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_slli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_slli_epi64">_mm_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sllv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sllv_epi32">_mm_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sllv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sllv_epi64">_mm_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_pd">_mm_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_ps">_mm_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_round_sd">_mm_maskz_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_round_ss">_mm_maskz_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_sd">_mm_maskz_sqrt_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sqrt_ss">_mm_maskz_sqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sra_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sra_epi32">_mm_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sra_epi64">_mm_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srai_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srai_epi32">_mm_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srai_epi64">_mm_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srav_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srav_epi32">_mm_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srav_epi64">_mm_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srl_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srl_epi32">_mm_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srl_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srl_epi64">_mm_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srli_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srli_epi32">_mm_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srli_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srli_epi64">_mm_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srlv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srlv_epi32">_mm_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srlv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_srlv_epi64">_mm_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_epi32">_mm_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_epi64">_mm_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_pd">_mm_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_ps">_mm_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_round_sd">_mm_maskz_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_round_ss">_mm_maskz_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_sd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_sd">_mm_maskz_sub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_ss.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_sub_ss">_mm_maskz_sub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_ternarylogic_epi32">_mm_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_ternarylogic_epi64">_mm_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpackhi_epi32">_mm_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpackhi_epi64">_mm_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpackhi_pd">_mm_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpackhi_ps">_mm_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpacklo_epi32">_mm_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpacklo_epi64">_mm_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_pd.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpacklo_pd">_mm_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_ps.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_unpacklo_ps">_mm_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_xor_epi32">_mm_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_maskz_xor_epi64">_mm_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_max_epi64">_mm_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_max_epu64">_mm_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_max_round_sd">_mm_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_max_round_ss">_mm_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epu64.html" title="fn core::core_arch::x86::avx512f::_mm_min_epu64">_mm_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_min_round_sd">_mm_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst , and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_min_round_ss">_mm_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_mul_round_sd">_mm_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_mul_round_ss">_mm_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_or_epi32">_mm_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_or_epi64">_mm_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_permutex2var_epi32">_mm_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_permutex2var_epi64">_mm_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_pd.html" title="fn core::core_arch::x86::avx512f::_mm_permutex2var_pd">_mm_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_ps.html" title="fn core::core_arch::x86::avx512f::_mm_permutex2var_ps">_mm_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_pd.html" title="fn core::core_arch::x86::avx512f::_mm_rcp14_pd">_mm_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_ps.html" title="fn core::core_arch::x86::avx512f::_mm_rcp14_ps">_mm_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_rcp14_sd">_mm_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_rcp14_ss">_mm_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rol_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_rol_epi32">_mm_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rol_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_rol_epi64">_mm_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rolv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_rolv_epi32">_mm_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rolv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_rolv_epi64">_mm_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ror_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_ror_epi32">_mm_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ror_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_ror_epi64">_mm_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rorv_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_rorv_epi32">_mm_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rorv_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_rorv_epi64">_mm_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_pd.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_pd">_mm_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_ps.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_ps">_mm_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_round_sd">_mm_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_round_ss">_mm_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_sd.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_sd">_mm_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_ss.html" title="fn core::core_arch::x86::avx512f::_mm_roundscale_ss">_mm_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt14_sd.html" title="fn core::core_arch::x86::avx512f::_mm_rsqrt14_sd">_mm_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt14_ss.html" title="fn core::core_arch::x86::avx512f::_mm_rsqrt14_ss">_mm_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_pd.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_pd">_mm_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_ps.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_ps">_mm_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_round_sd">_mm_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_round_ss">_mm_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_sd.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_sd">_mm_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_ss.html" title="fn core::core_arch::x86::avx512f::_mm_scalef_ss">_mm_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_sqrt_round_sd">_mm_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_sqrt_round_ss">_mm_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sra_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_sra_epi64">_mm_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srai_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_srai_epi64">_mm_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srav_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_srav_epi64">_mm_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_store_epi32">_mm_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_store_epi64">_mm_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_storeu_epi32">_mm_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_storeu_epi64">_mm_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_round_sd.html" title="fn core::core_arch::x86::avx512f::_mm_sub_round_sd">_mm_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_round_ss.html" title="fn core::core_arch::x86::avx512f::_mm_sub_round_ss">_mm_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ternarylogic_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_ternarylogic_epi32">_mm_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ternarylogic_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_ternarylogic_epi64">_mm_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_test_epi32_mask">_mm_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_test_epi64_mask">_mm_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi32_mask.html" title="fn core::core_arch::x86::avx512f::_mm_testn_epi32_mask">_mm_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi64_mask.html" title="fn core::core_arch::x86::avx512f::_mm_testn_epi64_mask">_mm_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_epi32.html" title="fn core::core_arch::x86::avx512f::_mm_xor_epi32">_mm_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_epi64.html" title="fn core::core_arch::x86::avx512f::_mm_xor_epi64">_mm_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class="item-name"><a class="fn" href="fn.psllid128.html" title="fn core::core_arch::x86::avx512f::psllid128">psllid128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psllid256.html" title="fn core::core_arch::x86::avx512f::psllid256">psllid256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.pslliq128.html" title="fn core::core_arch::x86::avx512f::pslliq128">pslliq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.pslliq256.html" title="fn core::core_arch::x86::avx512f::pslliq256">pslliq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psraid128.html" title="fn core::core_arch::x86::avx512f::psraid128">psraid128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psraid256.html" title="fn core::core_arch::x86::avx512f::psraid256">psraid256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psrlid128.html" title="fn core::core_arch::x86::avx512f::psrlid128">psrlid128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psrlid256.html" title="fn core::core_arch::x86::avx512f::psrlid256">psrlid256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psrliq128.html" title="fn core::core_arch::x86::avx512f::psrliq128">psrliq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.psrliq256.html" title="fn core::core_arch::x86::avx512f::psrliq256">psrliq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vaddpd.html" title="fn core::core_arch::x86::avx512f::vaddpd">vaddpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vaddps.html" title="fn core::core_arch::x86::avx512f::vaddps">vaddps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vaddsd.html" title="fn core::core_arch::x86::avx512f::vaddsd">vaddsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vaddss.html" title="fn core::core_arch::x86::avx512f::vaddss">vaddss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmppd.html" title="fn core::core_arch::x86::avx512f::vcmppd">vcmppd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmppd128.html" title="fn core::core_arch::x86::avx512f::vcmppd128">vcmppd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmppd256.html" title="fn core::core_arch::x86::avx512f::vcmppd256">vcmppd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmpps.html" title="fn core::core_arch::x86::avx512f::vcmpps">vcmpps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmpps128.html" title="fn core::core_arch::x86::avx512f::vcmpps128">vcmpps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmpps256.html" title="fn core::core_arch::x86::avx512f::vcmpps256">vcmpps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmpsd.html" title="fn core::core_arch::x86::avx512f::vcmpsd">vcmpsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcmpss.html" title="fn core::core_arch::x86::avx512f::vcmpss">vcmpss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcomisd.html" title="fn core::core_arch::x86::avx512f::vcomisd">vcomisd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcomiss.html" title="fn core::core_arch::x86::avx512f::vcomiss">vcomiss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompresspd.html" title="fn core::core_arch::x86::avx512f::vcompresspd">vcompresspd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompresspd128.html" title="fn core::core_arch::x86::avx512f::vcompresspd128">vcompresspd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompresspd256.html" title="fn core::core_arch::x86::avx512f::vcompresspd256">vcompresspd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressps.html" title="fn core::core_arch::x86::avx512f::vcompressps">vcompressps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressps128.html" title="fn core::core_arch::x86::avx512f::vcompressps128">vcompressps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressps256.html" title="fn core::core_arch::x86::avx512f::vcompressps256">vcompressps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstored.html" title="fn core::core_arch::x86::avx512f::vcompressstored">vcompressstored</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstored128.html" title="fn core::core_arch::x86::avx512f::vcompressstored128">vcompressstored128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstored256.html" title="fn core::core_arch::x86::avx512f::vcompressstored256">vcompressstored256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstorepd.html" title="fn core::core_arch::x86::avx512f::vcompressstorepd">vcompressstorepd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstorepd128.html" title="fn core::core_arch::x86::avx512f::vcompressstorepd128">vcompressstorepd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstorepd256.html" title="fn core::core_arch::x86::avx512f::vcompressstorepd256">vcompressstorepd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreps.html" title="fn core::core_arch::x86::avx512f::vcompressstoreps">vcompressstoreps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreps128.html" title="fn core::core_arch::x86::avx512f::vcompressstoreps128">vcompressstoreps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreps256.html" title="fn core::core_arch::x86::avx512f::vcompressstoreps256">vcompressstoreps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreq.html" title="fn core::core_arch::x86::avx512f::vcompressstoreq">vcompressstoreq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreq128.html" title="fn core::core_arch::x86::avx512f::vcompressstoreq128">vcompressstoreq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcompressstoreq256.html" title="fn core::core_arch::x86::avx512f::vcompressstoreq256">vcompressstoreq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtdq2ps.html" title="fn core::core_arch::x86::avx512f::vcvtdq2ps">vcvtdq2ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtpd2dq.html" title="fn core::core_arch::x86::avx512f::vcvtpd2dq">vcvtpd2dq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtpd2ps.html" title="fn core::core_arch::x86::avx512f::vcvtpd2ps">vcvtpd2ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtpd2udq.html" title="fn core::core_arch::x86::avx512f::vcvtpd2udq">vcvtpd2udq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtpd2udq128.html" title="fn core::core_arch::x86::avx512f::vcvtpd2udq128">vcvtpd2udq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtpd2udq256.html" title="fn core::core_arch::x86::avx512f::vcvtpd2udq256">vcvtpd2udq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtph2ps.html" title="fn core::core_arch::x86::avx512f::vcvtph2ps">vcvtph2ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2dq.html" title="fn core::core_arch::x86::avx512f::vcvtps2dq">vcvtps2dq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2pd.html" title="fn core::core_arch::x86::avx512f::vcvtps2pd">vcvtps2pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2ph.html" title="fn core::core_arch::x86::avx512f::vcvtps2ph">vcvtps2ph</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2ph128.html" title="fn core::core_arch::x86::avx512f::vcvtps2ph128">vcvtps2ph128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2ph256.html" title="fn core::core_arch::x86::avx512f::vcvtps2ph256">vcvtps2ph256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2udq.html" title="fn core::core_arch::x86::avx512f::vcvtps2udq">vcvtps2udq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2udq128.html" title="fn core::core_arch::x86::avx512f::vcvtps2udq128">vcvtps2udq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtps2udq256.html" title="fn core::core_arch::x86::avx512f::vcvtps2udq256">vcvtps2udq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtsd2si.html" title="fn core::core_arch::x86::avx512f::vcvtsd2si">vcvtsd2si</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtsd2ss.html" title="fn core::core_arch::x86::avx512f::vcvtsd2ss">vcvtsd2ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtsd2usi.html" title="fn core::core_arch::x86::avx512f::vcvtsd2usi">vcvtsd2usi</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtsi2sd.html" title="fn core::core_arch::x86::avx512f::vcvtsi2sd">vcvtsi2sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtsi2ss.html" title="fn core::core_arch::x86::avx512f::vcvtsi2ss">vcvtsi2ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtss2sd.html" title="fn core::core_arch::x86::avx512f::vcvtss2sd">vcvtss2sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtss2si.html" title="fn core::core_arch::x86::avx512f::vcvtss2si">vcvtss2si</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtss2usi.html" title="fn core::core_arch::x86::avx512f::vcvtss2usi">vcvtss2usi</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2dq.html" title="fn core::core_arch::x86::avx512f::vcvttpd2dq">vcvttpd2dq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2dq128.html" title="fn core::core_arch::x86::avx512f::vcvttpd2dq128">vcvttpd2dq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2dq256.html" title="fn core::core_arch::x86::avx512f::vcvttpd2dq256">vcvttpd2dq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2udq.html" title="fn core::core_arch::x86::avx512f::vcvttpd2udq">vcvttpd2udq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2udq128.html" title="fn core::core_arch::x86::avx512f::vcvttpd2udq128">vcvttpd2udq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttpd2udq256.html" title="fn core::core_arch::x86::avx512f::vcvttpd2udq256">vcvttpd2udq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2dq.html" title="fn core::core_arch::x86::avx512f::vcvttps2dq">vcvttps2dq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2dq128.html" title="fn core::core_arch::x86::avx512f::vcvttps2dq128">vcvttps2dq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2dq256.html" title="fn core::core_arch::x86::avx512f::vcvttps2dq256">vcvttps2dq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2udq.html" title="fn core::core_arch::x86::avx512f::vcvttps2udq">vcvttps2udq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2udq128.html" title="fn core::core_arch::x86::avx512f::vcvttps2udq128">vcvttps2udq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvttps2udq256.html" title="fn core::core_arch::x86::avx512f::vcvttps2udq256">vcvttps2udq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtudq2ps.html" title="fn core::core_arch::x86::avx512f::vcvtudq2ps">vcvtudq2ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtusi2sd.html" title="fn core::core_arch::x86::avx512f::vcvtusi2sd">vcvtusi2sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vcvtusi2ss.html" title="fn core::core_arch::x86::avx512f::vcvtusi2ss">vcvtusi2ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vdivpd.html" title="fn core::core_arch::x86::avx512f::vdivpd">vdivpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vdivps.html" title="fn core::core_arch::x86::avx512f::vdivps">vdivps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vdivsd.html" title="fn core::core_arch::x86::avx512f::vdivsd">vdivsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vdivss.html" title="fn core::core_arch::x86::avx512f::vdivss">vdivss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandpd.html" title="fn core::core_arch::x86::avx512f::vexpandpd">vexpandpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandpd128.html" title="fn core::core_arch::x86::avx512f::vexpandpd128">vexpandpd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandpd256.html" title="fn core::core_arch::x86::avx512f::vexpandpd256">vexpandpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandps.html" title="fn core::core_arch::x86::avx512f::vexpandps">vexpandps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandps128.html" title="fn core::core_arch::x86::avx512f::vexpandps128">vexpandps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vexpandps256.html" title="fn core::core_arch::x86::avx512f::vexpandps256">vexpandps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpd.html" title="fn core::core_arch::x86::avx512f::vfixupimmpd">vfixupimmpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpd128.html" title="fn core::core_arch::x86::avx512f::vfixupimmpd128">vfixupimmpd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpd256.html" title="fn core::core_arch::x86::avx512f::vfixupimmpd256">vfixupimmpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpdz.html" title="fn core::core_arch::x86::avx512f::vfixupimmpdz">vfixupimmpdz</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpdz128.html" title="fn core::core_arch::x86::avx512f::vfixupimmpdz128">vfixupimmpdz128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpdz256.html" title="fn core::core_arch::x86::avx512f::vfixupimmpdz256">vfixupimmpdz256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmps.html" title="fn core::core_arch::x86::avx512f::vfixupimmps">vfixupimmps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmps128.html" title="fn core::core_arch::x86::avx512f::vfixupimmps128">vfixupimmps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmps256.html" title="fn core::core_arch::x86::avx512f::vfixupimmps256">vfixupimmps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpsz.html" title="fn core::core_arch::x86::avx512f::vfixupimmpsz">vfixupimmpsz</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpsz128.html" title="fn core::core_arch::x86::avx512f::vfixupimmpsz128">vfixupimmpsz128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmpsz256.html" title="fn core::core_arch::x86::avx512f::vfixupimmpsz256">vfixupimmpsz256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmsd.html" title="fn core::core_arch::x86::avx512f::vfixupimmsd">vfixupimmsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmsdz.html" title="fn core::core_arch::x86::avx512f::vfixupimmsdz">vfixupimmsdz</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmss.html" title="fn core::core_arch::x86::avx512f::vfixupimmss">vfixupimmss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfixupimmssz.html" title="fn core::core_arch::x86::avx512f::vfixupimmssz">vfixupimmssz</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132pd.html" title="fn core::core_arch::x86::avx512f::vfmadd132pd">vfmadd132pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132pdround.html" title="fn core::core_arch::x86::avx512f::vfmadd132pdround">vfmadd132pdround</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132ps.html" title="fn core::core_arch::x86::avx512f::vfmadd132ps">vfmadd132ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132psround.html" title="fn core::core_arch::x86::avx512f::vfmadd132psround">vfmadd132psround</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132sd.html" title="fn core::core_arch::x86::avx512f::vfmadd132sd">vfmadd132sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmadd132ss.html" title="fn core::core_arch::x86::avx512f::vfmadd132ss">vfmadd132ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmaddsub213pd.html" title="fn core::core_arch::x86::avx512f::vfmaddsub213pd">vfmaddsub213pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vfmaddsub213ps.html" title="fn core::core_arch::x86::avx512f::vfmaddsub213ps">vfmaddsub213ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgatherdpd.html" title="fn core::core_arch::x86::avx512f::vgatherdpd">vgatherdpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgatherdps.html" title="fn core::core_arch::x86::avx512f::vgatherdps">vgatherdps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgatherqpd.html" title="fn core::core_arch::x86::avx512f::vgatherqpd">vgatherqpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgatherqps.html" title="fn core::core_arch::x86::avx512f::vgatherqps">vgatherqps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexppd.html" title="fn core::core_arch::x86::avx512f::vgetexppd">vgetexppd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexppd128.html" title="fn core::core_arch::x86::avx512f::vgetexppd128">vgetexppd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexppd256.html" title="fn core::core_arch::x86::avx512f::vgetexppd256">vgetexppd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexpps.html" title="fn core::core_arch::x86::avx512f::vgetexpps">vgetexpps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexpps128.html" title="fn core::core_arch::x86::avx512f::vgetexpps128">vgetexpps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexpps256.html" title="fn core::core_arch::x86::avx512f::vgetexpps256">vgetexpps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexpsd.html" title="fn core::core_arch::x86::avx512f::vgetexpsd">vgetexpsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetexpss.html" title="fn core::core_arch::x86::avx512f::vgetexpss">vgetexpss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantpd.html" title="fn core::core_arch::x86::avx512f::vgetmantpd">vgetmantpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantpd128.html" title="fn core::core_arch::x86::avx512f::vgetmantpd128">vgetmantpd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantpd256.html" title="fn core::core_arch::x86::avx512f::vgetmantpd256">vgetmantpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantps.html" title="fn core::core_arch::x86::avx512f::vgetmantps">vgetmantps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantps128.html" title="fn core::core_arch::x86::avx512f::vgetmantps128">vgetmantps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantps256.html" title="fn core::core_arch::x86::avx512f::vgetmantps256">vgetmantps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantsd.html" title="fn core::core_arch::x86::avx512f::vgetmantsd">vgetmantsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vgetmantss.html" title="fn core::core_arch::x86::avx512f::vgetmantss">vgetmantss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmaxpd.html" title="fn core::core_arch::x86::avx512f::vmaxpd">vmaxpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmaxps.html" title="fn core::core_arch::x86::avx512f::vmaxps">vmaxps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmaxsd.html" title="fn core::core_arch::x86::avx512f::vmaxsd">vmaxsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmaxss.html" title="fn core::core_arch::x86::avx512f::vmaxss">vmaxss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vminpd.html" title="fn core::core_arch::x86::avx512f::vminpd">vminpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vminps.html" title="fn core::core_arch::x86::avx512f::vminps">vminps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vminsd.html" title="fn core::core_arch::x86::avx512f::vminsd">vminsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vminss.html" title="fn core::core_arch::x86::avx512f::vminss">vminss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmulpd.html" title="fn core::core_arch::x86::avx512f::vmulpd">vmulpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmulps.html" title="fn core::core_arch::x86::avx512f::vmulps">vmulps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmulsd.html" title="fn core::core_arch::x86::avx512f::vmulsd">vmulsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vmulss.html" title="fn core::core_arch::x86::avx512f::vmulss">vmulss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpd.html" title="fn core::core_arch::x86::avx512f::vpcmpd">vpcmpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpd128.html" title="fn core::core_arch::x86::avx512f::vpcmpd128">vpcmpd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpd256.html" title="fn core::core_arch::x86::avx512f::vpcmpd256">vpcmpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpq.html" title="fn core::core_arch::x86::avx512f::vpcmpq">vpcmpq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpq128.html" title="fn core::core_arch::x86::avx512f::vpcmpq128">vpcmpq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpq256.html" title="fn core::core_arch::x86::avx512f::vpcmpq256">vpcmpq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpud.html" title="fn core::core_arch::x86::avx512f::vpcmpud">vpcmpud</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpud128.html" title="fn core::core_arch::x86::avx512f::vpcmpud128">vpcmpud128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpud256.html" title="fn core::core_arch::x86::avx512f::vpcmpud256">vpcmpud256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpuq.html" title="fn core::core_arch::x86::avx512f::vpcmpuq">vpcmpuq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpuq128.html" title="fn core::core_arch::x86::avx512f::vpcmpuq128">vpcmpuq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcmpuq256.html" title="fn core::core_arch::x86::avx512f::vpcmpuq256">vpcmpuq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressd.html" title="fn core::core_arch::x86::avx512f::vpcompressd">vpcompressd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressd128.html" title="fn core::core_arch::x86::avx512f::vpcompressd128">vpcompressd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressd256.html" title="fn core::core_arch::x86::avx512f::vpcompressd256">vpcompressd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressq.html" title="fn core::core_arch::x86::avx512f::vpcompressq">vpcompressq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressq128.html" title="fn core::core_arch::x86::avx512f::vpcompressq128">vpcompressq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpcompressq256.html" title="fn core::core_arch::x86::avx512f::vpcompressq256">vpcompressq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermd.html" title="fn core::core_arch::x86::avx512f::vpermd">vpermd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2d.html" title="fn core::core_arch::x86::avx512f::vpermi2d">vpermi2d</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2d128.html" title="fn core::core_arch::x86::avx512f::vpermi2d128">vpermi2d128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2d256.html" title="fn core::core_arch::x86::avx512f::vpermi2d256">vpermi2d256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2pd.html" title="fn core::core_arch::x86::avx512f::vpermi2pd">vpermi2pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2pd128.html" title="fn core::core_arch::x86::avx512f::vpermi2pd128">vpermi2pd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2pd256.html" title="fn core::core_arch::x86::avx512f::vpermi2pd256">vpermi2pd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2ps.html" title="fn core::core_arch::x86::avx512f::vpermi2ps">vpermi2ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2ps128.html" title="fn core::core_arch::x86::avx512f::vpermi2ps128">vpermi2ps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2ps256.html" title="fn core::core_arch::x86::avx512f::vpermi2ps256">vpermi2ps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2q.html" title="fn core::core_arch::x86::avx512f::vpermi2q">vpermi2q</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2q128.html" title="fn core::core_arch::x86::avx512f::vpermi2q128">vpermi2q128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermi2q256.html" title="fn core::core_arch::x86::avx512f::vpermi2q256">vpermi2q256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermilpd.html" title="fn core::core_arch::x86::avx512f::vpermilpd">vpermilpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermilps.html" title="fn core::core_arch::x86::avx512f::vpermilps">vpermilps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermpd.html" title="fn core::core_arch::x86::avx512f::vpermpd">vpermpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermpd256.html" title="fn core::core_arch::x86::avx512f::vpermpd256">vpermpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermps.html" title="fn core::core_arch::x86::avx512f::vpermps">vpermps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermq.html" title="fn core::core_arch::x86::avx512f::vpermq">vpermq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpermq256.html" title="fn core::core_arch::x86::avx512f::vpermq256">vpermq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandd.html" title="fn core::core_arch::x86::avx512f::vpexpandd">vpexpandd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandd128.html" title="fn core::core_arch::x86::avx512f::vpexpandd128">vpexpandd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandd256.html" title="fn core::core_arch::x86::avx512f::vpexpandd256">vpexpandd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandq.html" title="fn core::core_arch::x86::avx512f::vpexpandq">vpexpandq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandq128.html" title="fn core::core_arch::x86::avx512f::vpexpandq128">vpexpandq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpexpandq256.html" title="fn core::core_arch::x86::avx512f::vpexpandq256">vpexpandq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpgatherdd.html" title="fn core::core_arch::x86::avx512f::vpgatherdd">vpgatherdd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpgatherdq.html" title="fn core::core_arch::x86::avx512f::vpgatherdq">vpgatherdq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpgatherqd.html" title="fn core::core_arch::x86::avx512f::vpgatherqd">vpgatherqd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpgatherqq.html" title="fn core::core_arch::x86::avx512f::vpgatherqq">vpgatherqq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxsd.html" title="fn core::core_arch::x86::avx512f::vpmaxsd">vpmaxsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxsq.html" title="fn core::core_arch::x86::avx512f::vpmaxsq">vpmaxsq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxsq128.html" title="fn core::core_arch::x86::avx512f::vpmaxsq128">vpmaxsq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxsq256.html" title="fn core::core_arch::x86::avx512f::vpmaxsq256">vpmaxsq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxud.html" title="fn core::core_arch::x86::avx512f::vpmaxud">vpmaxud</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxuq.html" title="fn core::core_arch::x86::avx512f::vpmaxuq">vpmaxuq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxuq128.html" title="fn core::core_arch::x86::avx512f::vpmaxuq128">vpmaxuq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmaxuq256.html" title="fn core::core_arch::x86::avx512f::vpmaxuq256">vpmaxuq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminsd.html" title="fn core::core_arch::x86::avx512f::vpminsd">vpminsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminsq.html" title="fn core::core_arch::x86::avx512f::vpminsq">vpminsq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminsq128.html" title="fn core::core_arch::x86::avx512f::vpminsq128">vpminsq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminsq256.html" title="fn core::core_arch::x86::avx512f::vpminsq256">vpminsq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminud.html" title="fn core::core_arch::x86::avx512f::vpminud">vpminud</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminuq.html" title="fn core::core_arch::x86::avx512f::vpminuq">vpminuq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminuq128.html" title="fn core::core_arch::x86::avx512f::vpminuq128">vpminuq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpminuq256.html" title="fn core::core_arch::x86::avx512f::vpminuq256">vpminuq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdb128.html" title="fn core::core_arch::x86::avx512f::vpmovdb128">vpmovdb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdb256.html" title="fn core::core_arch::x86::avx512f::vpmovdb256">vpmovdb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdbmem.html" title="fn core::core_arch::x86::avx512f::vpmovdbmem">vpmovdbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovdbmem128">vpmovdbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovdbmem256">vpmovdbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdw128.html" title="fn core::core_arch::x86::avx512f::vpmovdw128">vpmovdw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdwmem.html" title="fn core::core_arch::x86::avx512f::vpmovdwmem">vpmovdwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovdwmem128">vpmovdwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovdwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovdwmem256">vpmovdwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqb.html" title="fn core::core_arch::x86::avx512f::vpmovqb">vpmovqb</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqb128.html" title="fn core::core_arch::x86::avx512f::vpmovqb128">vpmovqb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqb256.html" title="fn core::core_arch::x86::avx512f::vpmovqb256">vpmovqb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqbmem.html" title="fn core::core_arch::x86::avx512f::vpmovqbmem">vpmovqbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovqbmem128">vpmovqbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovqbmem256">vpmovqbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqd128.html" title="fn core::core_arch::x86::avx512f::vpmovqd128">vpmovqd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqdmem.html" title="fn core::core_arch::x86::avx512f::vpmovqdmem">vpmovqdmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqdmem128.html" title="fn core::core_arch::x86::avx512f::vpmovqdmem128">vpmovqdmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqdmem256.html" title="fn core::core_arch::x86::avx512f::vpmovqdmem256">vpmovqdmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqw128.html" title="fn core::core_arch::x86::avx512f::vpmovqw128">vpmovqw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqw256.html" title="fn core::core_arch::x86::avx512f::vpmovqw256">vpmovqw256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqwmem.html" title="fn core::core_arch::x86::avx512f::vpmovqwmem">vpmovqwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovqwmem128">vpmovqwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovqwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovqwmem256">vpmovqwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdb.html" title="fn core::core_arch::x86::avx512f::vpmovsdb">vpmovsdb</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdb128.html" title="fn core::core_arch::x86::avx512f::vpmovsdb128">vpmovsdb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdb256.html" title="fn core::core_arch::x86::avx512f::vpmovsdb256">vpmovsdb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdbmem.html" title="fn core::core_arch::x86::avx512f::vpmovsdbmem">vpmovsdbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovsdbmem128">vpmovsdbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovsdbmem256">vpmovsdbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdw.html" title="fn core::core_arch::x86::avx512f::vpmovsdw">vpmovsdw</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdw128.html" title="fn core::core_arch::x86::avx512f::vpmovsdw128">vpmovsdw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdw256.html" title="fn core::core_arch::x86::avx512f::vpmovsdw256">vpmovsdw256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdwmem.html" title="fn core::core_arch::x86::avx512f::vpmovsdwmem">vpmovsdwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovsdwmem128">vpmovsdwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsdwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovsdwmem256">vpmovsdwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqb.html" title="fn core::core_arch::x86::avx512f::vpmovsqb">vpmovsqb</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqb128.html" title="fn core::core_arch::x86::avx512f::vpmovsqb128">vpmovsqb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqb256.html" title="fn core::core_arch::x86::avx512f::vpmovsqb256">vpmovsqb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqbmem.html" title="fn core::core_arch::x86::avx512f::vpmovsqbmem">vpmovsqbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovsqbmem128">vpmovsqbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovsqbmem256">vpmovsqbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqd.html" title="fn core::core_arch::x86::avx512f::vpmovsqd">vpmovsqd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqd128.html" title="fn core::core_arch::x86::avx512f::vpmovsqd128">vpmovsqd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqd256.html" title="fn core::core_arch::x86::avx512f::vpmovsqd256">vpmovsqd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqdmem.html" title="fn core::core_arch::x86::avx512f::vpmovsqdmem">vpmovsqdmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqdmem128.html" title="fn core::core_arch::x86::avx512f::vpmovsqdmem128">vpmovsqdmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqdmem256.html" title="fn core::core_arch::x86::avx512f::vpmovsqdmem256">vpmovsqdmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqw.html" title="fn core::core_arch::x86::avx512f::vpmovsqw">vpmovsqw</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqw128.html" title="fn core::core_arch::x86::avx512f::vpmovsqw128">vpmovsqw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqw256.html" title="fn core::core_arch::x86::avx512f::vpmovsqw256">vpmovsqw256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqwmem.html" title="fn core::core_arch::x86::avx512f::vpmovsqwmem">vpmovsqwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovsqwmem128">vpmovsqwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovsqwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovsqwmem256">vpmovsqwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdb.html" title="fn core::core_arch::x86::avx512f::vpmovusdb">vpmovusdb</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdb128.html" title="fn core::core_arch::x86::avx512f::vpmovusdb128">vpmovusdb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdb256.html" title="fn core::core_arch::x86::avx512f::vpmovusdb256">vpmovusdb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdbmem.html" title="fn core::core_arch::x86::avx512f::vpmovusdbmem">vpmovusdbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovusdbmem128">vpmovusdbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovusdbmem256">vpmovusdbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdw.html" title="fn core::core_arch::x86::avx512f::vpmovusdw">vpmovusdw</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdw128.html" title="fn core::core_arch::x86::avx512f::vpmovusdw128">vpmovusdw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdw256.html" title="fn core::core_arch::x86::avx512f::vpmovusdw256">vpmovusdw256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdwmem.html" title="fn core::core_arch::x86::avx512f::vpmovusdwmem">vpmovusdwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovusdwmem128">vpmovusdwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusdwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovusdwmem256">vpmovusdwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqb.html" title="fn core::core_arch::x86::avx512f::vpmovusqb">vpmovusqb</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqb128.html" title="fn core::core_arch::x86::avx512f::vpmovusqb128">vpmovusqb128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqb256.html" title="fn core::core_arch::x86::avx512f::vpmovusqb256">vpmovusqb256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqbmem.html" title="fn core::core_arch::x86::avx512f::vpmovusqbmem">vpmovusqbmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqbmem128.html" title="fn core::core_arch::x86::avx512f::vpmovusqbmem128">vpmovusqbmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqbmem256.html" title="fn core::core_arch::x86::avx512f::vpmovusqbmem256">vpmovusqbmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqd.html" title="fn core::core_arch::x86::avx512f::vpmovusqd">vpmovusqd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqd128.html" title="fn core::core_arch::x86::avx512f::vpmovusqd128">vpmovusqd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqd256.html" title="fn core::core_arch::x86::avx512f::vpmovusqd256">vpmovusqd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqdmem.html" title="fn core::core_arch::x86::avx512f::vpmovusqdmem">vpmovusqdmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqdmem128.html" title="fn core::core_arch::x86::avx512f::vpmovusqdmem128">vpmovusqdmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqdmem256.html" title="fn core::core_arch::x86::avx512f::vpmovusqdmem256">vpmovusqdmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqw.html" title="fn core::core_arch::x86::avx512f::vpmovusqw">vpmovusqw</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqw128.html" title="fn core::core_arch::x86::avx512f::vpmovusqw128">vpmovusqw128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqw256.html" title="fn core::core_arch::x86::avx512f::vpmovusqw256">vpmovusqw256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqwmem.html" title="fn core::core_arch::x86::avx512f::vpmovusqwmem">vpmovusqwmem</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqwmem128.html" title="fn core::core_arch::x86::avx512f::vpmovusqwmem128">vpmovusqwmem128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmovusqwmem256.html" title="fn core::core_arch::x86::avx512f::vpmovusqwmem256">vpmovusqwmem256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmuldq.html" title="fn core::core_arch::x86::avx512f::vpmuldq">vpmuldq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpmuludq.html" title="fn core::core_arch::x86::avx512f::vpmuludq">vpmuludq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprold.html" title="fn core::core_arch::x86::avx512f::vprold">vprold</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprold128.html" title="fn core::core_arch::x86::avx512f::vprold128">vprold128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprold256.html" title="fn core::core_arch::x86::avx512f::vprold256">vprold256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolq.html" title="fn core::core_arch::x86::avx512f::vprolq">vprolq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolq128.html" title="fn core::core_arch::x86::avx512f::vprolq128">vprolq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolq256.html" title="fn core::core_arch::x86::avx512f::vprolq256">vprolq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvd.html" title="fn core::core_arch::x86::avx512f::vprolvd">vprolvd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvd128.html" title="fn core::core_arch::x86::avx512f::vprolvd128">vprolvd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvd256.html" title="fn core::core_arch::x86::avx512f::vprolvd256">vprolvd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvq.html" title="fn core::core_arch::x86::avx512f::vprolvq">vprolvq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvq128.html" title="fn core::core_arch::x86::avx512f::vprolvq128">vprolvq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprolvq256.html" title="fn core::core_arch::x86::avx512f::vprolvq256">vprolvq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprord.html" title="fn core::core_arch::x86::avx512f::vprord">vprord</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprord128.html" title="fn core::core_arch::x86::avx512f::vprord128">vprord128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprord256.html" title="fn core::core_arch::x86::avx512f::vprord256">vprord256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorq.html" title="fn core::core_arch::x86::avx512f::vprorq">vprorq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorq128.html" title="fn core::core_arch::x86::avx512f::vprorq128">vprorq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorq256.html" title="fn core::core_arch::x86::avx512f::vprorq256">vprorq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvd.html" title="fn core::core_arch::x86::avx512f::vprorvd">vprorvd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvd128.html" title="fn core::core_arch::x86::avx512f::vprorvd128">vprorvd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvd256.html" title="fn core::core_arch::x86::avx512f::vprorvd256">vprorvd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvq.html" title="fn core::core_arch::x86::avx512f::vprorvq">vprorvq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvq128.html" title="fn core::core_arch::x86::avx512f::vprorvq128">vprorvq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vprorvq256.html" title="fn core::core_arch::x86::avx512f::vprorvq256">vprorvq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpscatterdd.html" title="fn core::core_arch::x86::avx512f::vpscatterdd">vpscatterdd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpscatterdq.html" title="fn core::core_arch::x86::avx512f::vpscatterdq">vpscatterdq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpscatterdq256.html" title="fn core::core_arch::x86::avx512f::vpscatterdq256">vpscatterdq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpscatterqd.html" title="fn core::core_arch::x86::avx512f::vpscatterqd">vpscatterqd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpscatterqq.html" title="fn core::core_arch::x86::avx512f::vpscatterqq">vpscatterqq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpslld.html" title="fn core::core_arch::x86::avx512f::vpslld">vpslld</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsllid.html" title="fn core::core_arch::x86::avx512f::vpsllid">vpsllid</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpslliq.html" title="fn core::core_arch::x86::avx512f::vpslliq">vpslliq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsllq.html" title="fn core::core_arch::x86::avx512f::vpsllq">vpsllq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsllvd.html" title="fn core::core_arch::x86::avx512f::vpsllvd">vpsllvd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsllvq.html" title="fn core::core_arch::x86::avx512f::vpsllvq">vpsllvq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrad.html" title="fn core::core_arch::x86::avx512f::vpsrad">vpsrad</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraid512.html" title="fn core::core_arch::x86::avx512f::vpsraid512">vpsraid512</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraiq.html" title="fn core::core_arch::x86::avx512f::vpsraiq">vpsraiq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraiq128.html" title="fn core::core_arch::x86::avx512f::vpsraiq128">vpsraiq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraiq256.html" title="fn core::core_arch::x86::avx512f::vpsraiq256">vpsraiq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraq.html" title="fn core::core_arch::x86::avx512f::vpsraq">vpsraq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraq128.html" title="fn core::core_arch::x86::avx512f::vpsraq128">vpsraq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsraq256.html" title="fn core::core_arch::x86::avx512f::vpsraq256">vpsraq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsravd.html" title="fn core::core_arch::x86::avx512f::vpsravd">vpsravd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsravq.html" title="fn core::core_arch::x86::avx512f::vpsravq">vpsravq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsravq128.html" title="fn core::core_arch::x86::avx512f::vpsravq128">vpsravq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsravq256.html" title="fn core::core_arch::x86::avx512f::vpsravq256">vpsravq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrld.html" title="fn core::core_arch::x86::avx512f::vpsrld">vpsrld</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrlid.html" title="fn core::core_arch::x86::avx512f::vpsrlid">vpsrlid</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrliq.html" title="fn core::core_arch::x86::avx512f::vpsrliq">vpsrliq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrlq.html" title="fn core::core_arch::x86::avx512f::vpsrlq">vpsrlq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrlvd.html" title="fn core::core_arch::x86::avx512f::vpsrlvd">vpsrlvd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpsrlvq.html" title="fn core::core_arch::x86::avx512f::vpsrlvq">vpsrlvq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogd.html" title="fn core::core_arch::x86::avx512f::vpternlogd">vpternlogd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogd128.html" title="fn core::core_arch::x86::avx512f::vpternlogd128">vpternlogd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogd256.html" title="fn core::core_arch::x86::avx512f::vpternlogd256">vpternlogd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogq.html" title="fn core::core_arch::x86::avx512f::vpternlogq">vpternlogq</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogq128.html" title="fn core::core_arch::x86::avx512f::vpternlogq128">vpternlogq128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vpternlogq256.html" title="fn core::core_arch::x86::avx512f::vpternlogq256">vpternlogq256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14pd.html" title="fn core::core_arch::x86::avx512f::vrcp14pd">vrcp14pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14pd128.html" title="fn core::core_arch::x86::avx512f::vrcp14pd128">vrcp14pd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14pd256.html" title="fn core::core_arch::x86::avx512f::vrcp14pd256">vrcp14pd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14ps.html" title="fn core::core_arch::x86::avx512f::vrcp14ps">vrcp14ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14ps128.html" title="fn core::core_arch::x86::avx512f::vrcp14ps128">vrcp14ps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14ps256.html" title="fn core::core_arch::x86::avx512f::vrcp14ps256">vrcp14ps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14sd.html" title="fn core::core_arch::x86::avx512f::vrcp14sd">vrcp14sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrcp14ss.html" title="fn core::core_arch::x86::avx512f::vrcp14ss">vrcp14ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscalepd.html" title="fn core::core_arch::x86::avx512f::vrndscalepd">vrndscalepd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscalepd128.html" title="fn core::core_arch::x86::avx512f::vrndscalepd128">vrndscalepd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscalepd256.html" title="fn core::core_arch::x86::avx512f::vrndscalepd256">vrndscalepd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscaleps.html" title="fn core::core_arch::x86::avx512f::vrndscaleps">vrndscaleps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscaleps128.html" title="fn core::core_arch::x86::avx512f::vrndscaleps128">vrndscaleps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscaleps256.html" title="fn core::core_arch::x86::avx512f::vrndscaleps256">vrndscaleps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscalesd.html" title="fn core::core_arch::x86::avx512f::vrndscalesd">vrndscalesd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrndscaless.html" title="fn core::core_arch::x86::avx512f::vrndscaless">vrndscaless</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14pd.html" title="fn core::core_arch::x86::avx512f::vrsqrt14pd">vrsqrt14pd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14pd128.html" title="fn core::core_arch::x86::avx512f::vrsqrt14pd128">vrsqrt14pd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14pd256.html" title="fn core::core_arch::x86::avx512f::vrsqrt14pd256">vrsqrt14pd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14ps.html" title="fn core::core_arch::x86::avx512f::vrsqrt14ps">vrsqrt14ps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14ps128.html" title="fn core::core_arch::x86::avx512f::vrsqrt14ps128">vrsqrt14ps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14ps256.html" title="fn core::core_arch::x86::avx512f::vrsqrt14ps256">vrsqrt14ps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14sd.html" title="fn core::core_arch::x86::avx512f::vrsqrt14sd">vrsqrt14sd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vrsqrt14ss.html" title="fn core::core_arch::x86::avx512f::vrsqrt14ss">vrsqrt14ss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefpd.html" title="fn core::core_arch::x86::avx512f::vscalefpd">vscalefpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefpd128.html" title="fn core::core_arch::x86::avx512f::vscalefpd128">vscalefpd128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefpd256.html" title="fn core::core_arch::x86::avx512f::vscalefpd256">vscalefpd256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefps.html" title="fn core::core_arch::x86::avx512f::vscalefps">vscalefps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefps128.html" title="fn core::core_arch::x86::avx512f::vscalefps128">vscalefps128</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefps256.html" title="fn core::core_arch::x86::avx512f::vscalefps256">vscalefps256</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefsd.html" title="fn core::core_arch::x86::avx512f::vscalefsd">vscalefsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscalefss.html" title="fn core::core_arch::x86::avx512f::vscalefss">vscalefss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscatterdpd.html" title="fn core::core_arch::x86::avx512f::vscatterdpd">vscatterdpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscatterdps.html" title="fn core::core_arch::x86::avx512f::vscatterdps">vscatterdps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscatterqpd.html" title="fn core::core_arch::x86::avx512f::vscatterqpd">vscatterqpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vscatterqps.html" title="fn core::core_arch::x86::avx512f::vscatterqps">vscatterqps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsqrtpd.html" title="fn core::core_arch::x86::avx512f::vsqrtpd">vsqrtpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsqrtps.html" title="fn core::core_arch::x86::avx512f::vsqrtps">vsqrtps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsqrtsd.html" title="fn core::core_arch::x86::avx512f::vsqrtsd">vsqrtsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsqrtss.html" title="fn core::core_arch::x86::avx512f::vsqrtss">vsqrtss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsubpd.html" title="fn core::core_arch::x86::avx512f::vsubpd">vsubpd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsubps.html" title="fn core::core_arch::x86::avx512f::vsubps">vsubps</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsubsd.html" title="fn core::core_arch::x86::avx512f::vsubsd">vsubsd</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn.vsubss.html" title="fn core::core_arch::x86::avx512f::vsubss">vsubss</a><span title="Restricted Visibility">&nbsp;🔒</span> <sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span></div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_ps.html" title="fn core::core_arch::x86::avx512f::_mm512_storeu_ps">_mm512_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">Stores 512-bits (composed of 16 packed single-precision (32-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li></ul></section></div></main></body></html>