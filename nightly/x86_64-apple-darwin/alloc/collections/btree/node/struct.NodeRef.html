<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A reference to a node."><title>NodeRef in alloc::collections::btree::node - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="alloc" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (b2b34bd83 2023-06-06)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-48600a9606eff342.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"><script src="/nav.js"></script>
</head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../alloc/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../alloc/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">NodeRef</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield._marker">_marker</a></li><li><a href="#structfield.height">height</a></li><li><a href="#structfield.node">node</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.append_from_sorted_iters">append_from_sorted_iters</a></li><li><a href="#method.as_internal_mut">as_internal_mut</a></li><li><a href="#method.as_internal_ptr">as_internal_ptr</a></li><li><a href="#method.as_leaf_dying">as_leaf_dying</a></li><li><a href="#method.as_leaf_mut">as_leaf_mut</a></li><li><a href="#method.as_leaf_ptr">as_leaf_ptr</a></li><li><a href="#method.ascend">ascend</a></li><li><a href="#method.awaken">awaken</a></li><li><a href="#method.borrow_mut">borrow_mut</a></li><li><a href="#method.borrow_valmut">borrow_valmut</a></li><li><a href="#method.bulk_push">bulk_push</a></li><li><a href="#method.calc_length">calc_length</a></li><li><a href="#method.calc_split_length">calc_split_length</a></li><li><a href="#method.cast_to_internal_unchecked">cast_to_internal_unchecked</a></li><li><a href="#method.cast_to_leaf_unchecked">cast_to_leaf_unchecked</a></li><li><a href="#method.choose_parent_kv">choose_parent_kv</a></li><li><a href="#method.clear_parent_link">clear_parent_link</a></li><li><a href="#method.correct_all_childrens_parent_links">correct_all_childrens_parent_links</a></li><li><a href="#method.correct_childrens_parent_links">correct_childrens_parent_links</a></li><li><a href="#method.deallocate_and_ascend">deallocate_and_ascend</a></li><li><a href="#method.dormant">dormant</a></li><li><a href="#method.edge_area_mut">edge_area_mut</a></li><li><a href="#method.eq">eq</a></li><li><a href="#method.find_key_index">find_key_index</a></li><li><a href="#method.find_leaf_edges_spanning_range">find_leaf_edges_spanning_range</a></li><li><a href="#method.find_lower_bound_edge">find_lower_bound_edge</a></li><li><a href="#method.find_lower_bound_index">find_lower_bound_index</a></li><li><a href="#method.find_upper_bound_edge">find_upper_bound_edge</a></li><li><a href="#method.find_upper_bound_index">find_upper_bound_index</a></li><li><a href="#method.first_edge">first_edge</a></li><li><a href="#method.first_kv">first_kv</a></li><li><a href="#method.first_leaf_edge">first_leaf_edge</a></li><li><a href="#method.fix_left_border">fix_left_border</a></li><li><a href="#method.fix_node_and_affected_ancestors">fix_node_and_affected_ancestors</a></li><li><a href="#method.fix_node_through_parent">fix_node_through_parent</a></li><li><a href="#method.fix_right_border">fix_right_border</a></li><li><a href="#method.fix_right_border_of_plentiful">fix_right_border_of_plentiful</a></li><li><a href="#method.fix_top">fix_top</a></li><li><a href="#method.force">force</a></li><li><a href="#method.forget_type">forget_type</a></li><li><a href="#method.forget_type-1">forget_type</a></li><li><a href="#method.from_internal">from_internal</a></li><li><a href="#method.from_new_internal">from_new_internal</a></li><li><a href="#method.from_new_leaf">from_new_leaf</a></li><li><a href="#method.full_range">full_range</a></li><li><a href="#method.full_range-1">full_range</a></li><li><a href="#method.full_range-2">full_range</a></li><li><a href="#method.height">height</a></li><li><a href="#method.into_dying">into_dying</a></li><li><a href="#method.into_key_val_mut_at">into_key_val_mut_at</a></li><li><a href="#method.into_leaf">into_leaf</a></li><li><a href="#method.into_leaf_mut">into_leaf_mut</a></li><li><a href="#method.key_area_mut">key_area_mut</a></li><li><a href="#method.keys">keys</a></li><li><a href="#method.last_edge">last_edge</a></li><li><a href="#method.last_kv">last_kv</a></li><li><a href="#method.last_leaf_edge">last_leaf_edge</a></li><li><a href="#method.len">len</a></li><li><a href="#method.len_mut">len_mut</a></li><li><a href="#method.lower_bound">lower_bound</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_internal">new_internal</a></li><li><a href="#method.new_leaf">new_leaf</a></li><li><a href="#method.new_pillar">new_pillar</a></li><li><a href="#method.pop_internal_level">pop_internal_level</a></li><li><a href="#method.push">push</a></li><li><a href="#method.push-1">push</a></li><li><a href="#method.push_internal_level">push_internal_level</a></li><li><a href="#method.range_search">range_search</a></li><li><a href="#method.range_search-1">range_search</a></li><li><a href="#method.reborrow">reborrow</a></li><li><a href="#method.reborrow_mut">reborrow_mut</a></li><li><a href="#method.search_node">search_node</a></li><li><a href="#method.search_tree">search_tree</a></li><li><a href="#method.search_tree_for_bifurcation">search_tree_for_bifurcation</a></li><li><a href="#method.set_parent_link">set_parent_link</a></li><li><a href="#method.split_off">split_off</a></li><li><a href="#method.upper_bound">upper_bound</a></li><li><a href="#method.val_area_mut">val_area_mut</a></li><li><a href="#method.visit_nodes_in_order">visit_nodes_in_order</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E">Clone</a></li><li><a href="#impl-Copy-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E">Copy</a></li><li><a href="#impl-Send-for-NodeRef%3CDying,+K,+V,+Type%3E">Send</a></li><li><a href="#impl-Send-for-NodeRef%3CImmut%3C'_%3E,+K,+V,+Type%3E">Send</a></li><li><a href="#impl-Send-for-NodeRef%3CMut%3C'_%3E,+K,+V,+Type%3E">Send</a></li><li><a href="#impl-Send-for-NodeRef%3COwned,+K,+V,+Type%3E">Send</a></li><li><a href="#impl-Send-for-NodeRef%3CValMut%3C'_%3E,+K,+V,+Type%3E">Send</a></li><li><a href="#impl-Sync-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Send-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">!Send</a></li><li><a href="#impl-RefUnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">Into&lt;U&gt;</a></li><li><a href="#impl-NonDrop-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">NonDrop</a></li><li><a href="#impl-ToOwned-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In alloc::collections::btree::node</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../../index.html">alloc</a>::<wbr><a href="../../index.html">collections</a>::<wbr><a href="../index.html">btree</a>::<wbr><a href="index.html">node</a>::<wbr><a class="struct" href="#">NodeRef</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../../src/alloc/collections/btree/node.rs.html#182-193">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct NodeRef&lt;BorrowType, K, V, Type&gt; {
    height: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>,
    node: <a class="struct" href="../../../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;&gt;,
    _marker: <a class="struct" href="../../../../core/marker/struct.PhantomData.html" title="struct core::marker::PhantomData">PhantomData</a>&lt;<a class="primitive" href="../../../../core/primitive.tuple.html">(BorrowType, Type)</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A reference to a node.</p>
<p>This type has a number of parameters that controls how it acts:</p>
<ul>
<li><code>BorrowType</code>: A dummy type that describes the kind of borrow and carries a lifetime.
<ul>
<li>When this is <code>Immut&lt;'a&gt;</code>, the <code>NodeRef</code> acts roughly like <code>&amp;'a Node</code>.</li>
<li>When this is <code>ValMut&lt;'a&gt;</code>, the <code>NodeRef</code> acts roughly like <code>&amp;'a Node</code>
with respect to keys and tree structure, but also allows many
mutable references to values throughout the tree to coexist.</li>
<li>When this is <code>Mut&lt;'a&gt;</code>, the <code>NodeRef</code> acts roughly like <code>&amp;'a mut Node</code>,
although insert methods allow a mutable pointer to a value to coexist.</li>
<li>When this is <code>Owned</code>, the <code>NodeRef</code> acts roughly like <code>Box&lt;Node&gt;</code>,
but does not have a destructor, and must be cleaned up manually.</li>
<li>When this is <code>Dying</code>, the <code>NodeRef</code> still acts roughly like <code>Box&lt;Node&gt;</code>,
but has methods to destroy the tree bit by bit, and ordinary methods,
while not marked as unsafe to call, can invoke UB if called incorrectly.
Since any <code>NodeRef</code> allows navigating through the tree, <code>BorrowType</code>
effectively applies to the entire tree, not just to the node itself.</li>
</ul>
</li>
<li><code>K</code> and <code>V</code>: These are the types of keys and values stored in the nodes.</li>
<li><code>Type</code>: This can be <code>Leaf</code>, <code>Internal</code>, or <code>LeafOrInternal</code>. When this is
<code>Leaf</code>, the <code>NodeRef</code> points to a leaf node, when this is <code>Internal</code> the
<code>NodeRef</code> points to an internal node, and when this is <code>LeafOrInternal</code> the
<code>NodeRef</code> could be pointing to either type of node.
<code>Type</code> is named <code>NodeType</code> when used outside <code>NodeRef</code>.</li>
</ul>
<p>Both <code>BorrowType</code> and <code>NodeType</code> restrict what methods we implement, to
exploit static type safety. There are limitations in the way we can apply
such restrictions:</p>
<ul>
<li>For each type parameter, we can only define a method either generically
or for one particular type. For example, we cannot define a method like
<code>into_kv</code> generically for all <code>BorrowType</code>, or once for all types that
carry a lifetime, because we want it to return <code>&amp;'a</code> references.
Therefore, we define it only for the least powerful type <code>Immut&lt;'a&gt;</code>.</li>
<li>We cannot get implicit coercion from say <code>Mut&lt;'a&gt;</code> to <code>Immut&lt;'a&gt;</code>.
Therefore, we have to explicitly call <code>reborrow</code> on a more powerful
<code>NodeRef</code> in order to reach a method like <code>into_kv</code>.</li>
</ul>
<p>All methods on <code>NodeRef</code> that return some kind of reference, either:</p>
<ul>
<li>Take <code>self</code> by value, and return the lifetime carried by <code>BorrowType</code>.
Sometimes, to invoke such a method, we need to call <code>reborrow_mut</code>.</li>
<li>Take <code>self</code> by reference, and (implicitly) return that reference’s
lifetime, instead of the lifetime carried by <code>BorrowType</code>. That way,
the borrow checker guarantees that the <code>NodeRef</code> remains borrowed as long
as the returned reference is used.
The methods supporting insert bend this rule by returning a raw pointer,
i.e., a reference without any lifetime.</li>
</ul>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.height" class="structfield small-section-header"><a href="#structfield.height" class="anchor field">§</a><code>height: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a></code></span><div class="docblock"><p>The number of levels that the node and the level of leaves are apart, a
constant of the node that cannot be entirely described by <code>Type</code>, and that
the node itself does not store. We only need to store the height of the root
node, and derive every other node’s height from it.
Must be zero if <code>Type</code> is <code>Leaf</code> and non-zero if <code>Type</code> is <code>Internal</code>.</p>
</div><span id="structfield.node" class="structfield small-section-header"><a href="#structfield.node" class="anchor field">§</a><code>node: <a class="struct" href="../../../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;&gt;</code></span><div class="docblock"><p>The pointer to the leaf or internal node. The definition of <code>InternalNode</code>
ensures that the pointer is valid either way.</p>
</div><span id="structfield._marker" class="structfield small-section-header"><a href="#structfield._marker" class="anchor field">§</a><code>_marker: <a class="struct" href="../../../../core/marker/struct.PhantomData.html" title="struct core::marker::PhantomData">PhantomData</a>&lt;<a class="primitive" href="../../../../core/primitive.tuple.html">(BorrowType, Type)</a>&gt;</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/append.rs.html#6-91">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.append_from_sorted_iters" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/append.rs.html#18-33">source</a><h4 class="code-header">pub fn <a href="#method.append_from_sorted_iters" class="fn">append_from_sorted_iters</a>&lt;I, A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    &amp;mut self,
    left: I,
    right: I,
    length: &amp;mut <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>,
    alloc: A
)<span class="where fmt-newline">where
    K: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    I: <a class="trait" href="../../../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="../../../../core/primitive.tuple.html">(K, V)</a>&gt; + <a class="trait" href="../../../../core/iter/traits/marker/trait.FusedIterator.html" title="trait core::iter::traits::marker::FusedIterator">FusedIterator</a>,</span></h4></section></summary><div class="docblock"><p>Appends all key-value pairs from the union of two ascending iterators,
incrementing a <code>length</code> variable along the way. The latter makes it
easier for the caller to avoid a leak when a drop handler panicks.</p>
<p>If both iterators produce the same key, this method drops the pair from
the left iterator and appends the pair from the right iterator.</p>
<p>If you want the tree to end up in a strictly ascending order, like for
a <code>BTreeMap</code>, both iterators should produce keys in strictly ascending
order, each greater than all keys in the tree, including any keys
already in the tree upon entry.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bulk_push" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/append.rs.html#38-90">source</a><h4 class="code-header">pub fn <a href="#method.bulk_push" class="fn">bulk_push</a>&lt;I, A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    &amp;mut self,
    iter: I,
    length: &amp;mut <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>,
    alloc: A
)<span class="where fmt-newline">where
    I: <a class="trait" href="../../../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="../../../../core/primitive.tuple.html">(K, V)</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Pushes all key-value pairs to the end of the tree, incrementing a
<code>length</code> variable along the way. The latter makes it easier for the
caller to avoid a leak when the iterator panicks.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#5-47">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fix_node_through_parent" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#10-46">source</a><h4 class="code-header">fn <a href="#method.fix_node_through_parent" class="fn">fix_node_through_parent</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    self,
    alloc: A
) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../../../../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;&gt;, Self&gt;</h4></section></summary><div class="docblock"><p>Stocks up a possibly underfull node by merging with or stealing from a
sibling. If successful but at the cost of shrinking the parent node,
returns that shrunk parent node. Returns an <code>Err</code> if the node is
an empty root.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#49-66">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fix_node_and_affected_ancestors" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#57-65">source</a><h4 class="code-header">pub fn <a href="#method.fix_node_and_affected_ancestors" class="fn">fix_node_and_affected_ancestors</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    self,
    alloc: A
) -&gt; <a class="primitive" href="../../../../core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Stocks up a possibly underfull node, and if that causes its parent node
to shrink, stocks up the parent, recursively.
Returns <code>true</code> if it fixed the tree, <code>false</code> if it couldn’t because the
root node became empty.</p>
<p>This method does not expect ancestors to already be underfull upon entry
and panics if it encounters an empty ancestor.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#68-115">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fix_top" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#70-74">source</a><h4 class="code-header">pub fn <a href="#method.fix_top" class="fn">fix_top</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(&amp;mut self, alloc: A)</h4></section></summary><div class="docblock"><p>Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fix_right_border" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#79-85">source</a><h4 class="code-header">pub fn <a href="#method.fix_right_border" class="fn">fix_right_border</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(&amp;mut self, alloc: A)</h4></section></summary><div class="docblock"><p>Stocks up or merge away any underfull nodes on the right border of the
tree. The other nodes, those that are not the root nor a rightmost edge,
must already have at least MIN_LEN elements.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fix_left_border" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#88-94">source</a><h4 class="code-header">pub fn <a href="#method.fix_left_border" class="fn">fix_left_border</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(&amp;mut self, alloc: A)</h4></section></summary><div class="docblock"><p>The symmetric clone of <code>fix_right_border</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fix_right_border_of_plentiful" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/fix.rs.html#99-114">source</a><h4 class="code-header">pub fn <a href="#method.fix_right_border_of_plentiful" class="fn">fix_right_border_of_plentiful</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Stocks up any underfull nodes on the right border of the tree.
The other nodes, those that are neither the root nor a rightmost edge,
must be prepared to have up to MIN_LEN elements stolen.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#251-300">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType: <a class="trait" href="marker/trait.BorrowType.html" title="trait alloc::collections::btree::node::marker::BorrowType">BorrowType</a>, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.find_leaf_edges_spanning_range" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#265-299">source</a><h4 class="code-header">unsafe fn <a href="#method.find_leaf_edges_spanning_range" class="fn">find_leaf_edges_spanning_range</a>&lt;Q, R&gt;(
    self,
    range: R
) -&gt; <a class="struct" href="../navigate/struct.LeafRange.html" title="struct alloc::collections::btree::navigate::LeafRange">LeafRange</a>&lt;BorrowType, K, V&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    R: <a class="trait" href="../../../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Finds the distinct leaf edges delimiting a specified range in a tree.</p>
<p>If such distinct edges exist, returns them in ascending order, meaning
that a non-zero number of calls to <code>next_unchecked</code> on the <code>front</code> of
the result and/or calls to <code>next_back_unchecked</code> on the <code>back</code> of the
result will eventually reach the same edge.</p>
<p>If there are no such edges, i.e., if the tree contains no key within
the range, returns an empty <code>front</code> and <code>back</code>.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>Unless <code>BorrowType</code> is <code>Immut</code>, do not use the handles to visit the same
KV twice.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#312-331">source</a><a href="#impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.range_search" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#317-325">source</a><h4 class="code-header">pub fn <a href="#method.range_search" class="fn">range_search</a>&lt;Q, R&gt;(self, range: R) -&gt; <a class="struct" href="../navigate/struct.LeafRange.html" title="struct alloc::collections::btree::navigate::LeafRange">LeafRange</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V&gt;<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    R: <a class="trait" href="../../../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Finds the pair of leaf edges delimiting a specific range in a tree.</p>
<p>The result is meaningful only if the tree is ordered by key, like the tree
in a <code>BTreeMap</code> is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.full_range" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#328-330">source</a><h4 class="code-header">pub fn <a href="#method.full_range" class="fn">full_range</a>(self) -&gt; <a class="struct" href="../navigate/struct.LazyLeafRange.html" title="struct alloc::collections::btree::navigate::LazyLeafRange">LazyLeafRange</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V&gt;</h4></section></summary><div class="docblock"><p>Finds the pair of leaf edges delimiting an entire tree.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CValMut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#333-361">source</a><a href="#impl-NodeRef%3CValMut%3C'a%3E,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.range_search-1" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#343-350">source</a><h4 class="code-header">pub fn <a href="#method.range_search-1" class="fn">range_search</a>&lt;Q, R&gt;(self, range: R) -&gt; <a class="struct" href="../navigate/struct.LeafRange.html" title="struct alloc::collections::btree::navigate::LeafRange">LeafRange</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'a&gt;, K, V&gt;<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    R: <a class="trait" href="../../../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Splits a unique reference into a pair of leaf edges delimiting a specified range.
The result are non-unique references allowing (some) mutation, which must be used
carefully.</p>
<p>The result is meaningful only if the tree is ordered by key, like the tree
in a <code>BTreeMap</code> is.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Do not use the duplicate handles to visit the same KV twice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.full_range-1" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#355-360">source</a><h4 class="code-header">pub fn <a href="#method.full_range-1" class="fn">full_range</a>(self) -&gt; <a class="struct" href="../navigate/struct.LazyLeafRange.html" title="struct alloc::collections::btree::navigate::LazyLeafRange">LazyLeafRange</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'a&gt;, K, V&gt;</h4></section></summary><div class="docblock"><p>Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.
The results are non-unique references allowing mutation (of values only), so must be used
with care.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CDying,+K,+V,+LeafOrInternal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#363-373">source</a><a href="#impl-NodeRef%3CDying,+K,+V,+LeafOrInternal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.full_range-2" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#367-372">source</a><h4 class="code-header">pub fn <a href="#method.full_range-2" class="fn">full_range</a>(self) -&gt; <a class="struct" href="../navigate/struct.LazyLeafRange.html" title="struct alloc::collections::btree::navigate::LazyLeafRange">LazyLeafRange</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V&gt;</h4></section></summary><div class="docblock"><p>Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.
The results are non-unique references allowing massively destructive mutation, so must be
used with the utmost care.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#627-653">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType: <a class="trait" href="marker/trait.BorrowType.html" title="trait alloc::collections::btree::node::marker::BorrowType">BorrowType</a>, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.first_leaf_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#631-639">source</a><h4 class="code-header">pub fn <a href="#method.first_leaf_edge" class="fn">first_leaf_edge</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the leftmost leaf edge in or underneath a node - in other words, the edge
you need first when navigating forward (or last when navigating backward).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_leaf_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#644-652">source</a><h4 class="code-header">pub fn <a href="#method.last_leaf_edge" class="fn">last_leaf_edge</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the rightmost leaf edge in or underneath a node - in other words, the edge
you need last when navigating forward (or first when navigating backward).</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+LeafOrInternal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#661-706">source</a><a href="#impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+LeafOrInternal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.visit_nodes_in_order" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#665-694">source</a><h4 class="code-header">pub fn <a href="#method.visit_nodes_in_order" class="fn">visit_nodes_in_order</a>&lt;F&gt;(self, visit: F)<span class="where fmt-newline">where
    F: <a class="trait" href="../../../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="enum" href="../navigate/enum.Position.html" title="enum alloc::collections::btree::navigate::Position">Position</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V&gt;),</span></h4></section></summary><div class="docblock"><p>Visits leaf nodes and internal KVs in order of ascending keys, and also
visits internal nodes as a whole in a depth first order, meaning that
internal nodes precede their individual KVs and their child nodes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.calc_length" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#697-705">source</a><h4 class="code-header">pub fn <a href="#method.calc_length" class="fn">calc_length</a>(self) -&gt; <a class="primitive" href="../../../../core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Calculates the number of elements in a (sub)tree.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#736-782">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType: <a class="trait" href="marker/trait.BorrowType.html" title="trait alloc::collections::btree::node::marker::BorrowType">BorrowType</a>, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.lower_bound" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#739-758">source</a><h4 class="code-header">pub fn <a href="#method.lower_bound" class="fn">lower_bound</a>&lt;Q&gt;(
    self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>&gt;
) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the leaf edge corresponding to the first point at which the
given bound is true.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.upper_bound" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/navigate.rs.html#762-781">source</a><h4 class="code-header">pub fn <a href="#method.upper_bound" class="fn">upper_bound</a>&lt;Q&gt;(
    self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>&gt;
) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the leaf edge corresponding to the last point at which the
given bound is true.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+Leaf%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#215-223">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+Leaf%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;</h3></section></summary><div class="impl-items"><section id="method.new_leaf" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#216-218">source</a><h4 class="code-header">pub fn <a href="#method.new_leaf" class="fn">new_leaf</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(alloc: A) -&gt; Self</h4></section><section id="method.from_new_leaf" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#220-222">source</a><h4 class="code-header">fn <a href="#method.from_new_leaf" class="fn">from_new_leaf</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(leaf: <a class="struct" href="../../../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;, A&gt;) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+Internal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#225-244">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+Internal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><section id="method.new_internal" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#226-230">source</a><h4 class="code-header">fn <a href="#method.new_internal" class="fn">new_internal</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    child: <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;,
    alloc: A
) -&gt; Self</h4></section><details class="toggle method-toggle" open><summary><section id="method.from_new_internal" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#234-243">source</a><h4 class="code-header">unsafe fn <a href="#method.from_new_internal" class="fn">from_new_internal</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    internal: <a class="struct" href="../../../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="struct.InternalNode.html" title="struct alloc::collections::btree::node::InternalNode">InternalNode</a>&lt;K, V&gt;, A&gt;,
    height: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>
) -&gt; Self</h4></section></summary><div class="docblock"><h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p><code>height</code> must not be zero.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#246-252">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_internal" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#248-251">source</a><h4 class="code-header">fn <a href="#method.from_internal" class="fn">from_internal</a>(node: <a class="struct" href="../../../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="struct" href="struct.InternalNode.html" title="struct alloc::collections::btree::node::InternalNode">InternalNode</a>&lt;K, V&gt;&gt;, height: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Unpack a node reference that was packed as <code>NodeRef::parent</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#254-262">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_internal_ptr" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#258-261">source</a><h4 class="code-header">fn <a href="#method.as_internal_ptr" class="fn">as_internal_ptr</a>(this: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="../../../../core/primitive.pointer.html">*mut </a><a class="struct" href="struct.InternalNode.html" title="struct alloc::collections::btree::node::InternalNode">InternalNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Exposes the data of an internal node.</p>
<p>Returns a raw ptr to avoid invalidating other references to this node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#264-270">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_internal_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#266-269">source</a><h4 class="code-header">fn <a href="#method.as_internal_mut" class="fn">as_internal_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.InternalNode.html" title="struct alloc::collections::btree::node::InternalNode">InternalNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Borrows exclusive access to the data of an internal node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#272-306">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#277-281">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="../../../../core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Finds the length of the node. This is the number of keys or values.
The number of edges is <code>len() + 1</code>.
Note that, despite being safe, calling this function can have the side effect
of invalidating mutable references that unsafe code has created.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.height" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#288-290">source</a><h4 class="code-header">pub fn <a href="#method.height" class="fn">height</a>(&amp;self) -&gt; <a class="primitive" href="../../../../core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of levels that the node and leaves are apart. Zero
height means the node is a leaf itself. If you picture trees with the
root on top, the number says at which elevation the node appears.
If you picture trees with leaves on top, the number says how high
the tree extends above the node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reborrow" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#293-295">source</a><h4 class="code-header">pub fn <a href="#method.reborrow" class="fn">reborrow</a>(&amp;self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'_&gt;, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Temporarily takes out another, immutable reference to the same node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_leaf_ptr" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#300-305">source</a><h4 class="code-header">fn <a href="#method.as_leaf_ptr" class="fn">as_leaf_ptr</a>(this: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="../../../../core/primitive.pointer.html">*mut </a><a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Exposes the leaf portion of any leaf or internal node.</p>
<p>Returns a raw ptr to avoid invalidating other references to this node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#308-360">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType: <a class="trait" href="marker/trait.BorrowType.html" title="trait alloc::collections::btree::node::marker::BorrowType">BorrowType</a>, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.ascend" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#318-336">source</a><h4 class="code-header">pub fn <a href="#method.ascend" class="fn">ascend</a>(
    self
) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;, Self&gt;</h4></section></summary><div class="docblock"><p>Finds the parent of the current node. Returns <code>Ok(handle)</code> if the current
node actually has a parent, where <code>handle</code> points to the edge of the parent
that points to the current node. Returns <code>Err(self)</code> if the current node has
no parent, giving back the original <code>NodeRef</code>.</p>
<p>The method name assumes you picture trees with the root node on top.</p>
<p><code>edge.descend().ascend().unwrap()</code> and <code>node.ascend().unwrap().descend()</code> should
both, upon success, do nothing.</p>
</div></details><section id="method.first_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#338-340">source</a><h4 class="code-header">pub fn <a href="#method.first_edge" class="fn">first_edge</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;</h4></section><section id="method.last_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#342-345">source</a><h4 class="code-header">pub fn <a href="#method.last_edge" class="fn">last_edge</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.first_kv" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#348-352">source</a><h4 class="code-header">pub fn <a href="#method.first_kv" class="fn">first_kv</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.KV.html" title="enum alloc::collections::btree::node::marker::KV">KV</a>&gt;</h4></section></summary><div class="docblock"><p>Note that <code>self</code> must be nonempty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_kv" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#355-359">source</a><h4 class="code-header">pub fn <a href="#method.last_kv" class="fn">last_kv</a>(self) -&gt; <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.KV.html" title="enum alloc::collections::btree::node::marker::KV">KV</a>&gt;</h4></section></summary><div class="docblock"><p>Note that <code>self</code> must be nonempty.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#362-373">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#364-372">source</a><h4 class="code-header">fn <a href="#method.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="../../../../core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Could be a public implementation of PartialEq, but only used in this module.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#375-390">source</a><a href="#impl-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_leaf" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#377-381">source</a><h4 class="code-header">fn <a href="#method.into_leaf" class="fn">into_leaf</a>(self) -&gt; &amp;'a <a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Exposes the leaf portion of any leaf or internal node in an immutable tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#384-389">source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../../../core/primitive.slice.html">[K]</a></h4></section></summary><div class="docblock"><p>Borrows a view into the keys stored in the node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CDying,+K,+V,+LeafOrInternal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#392-415">source</a><a href="#impl-NodeRef%3CDying,+K,+V,+LeafOrInternal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deallocate_and_ascend" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#396-414">source</a><h4 class="code-header">pub unsafe fn <a href="#method.deallocate_and_ascend" class="fn">deallocate_and_ascend</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    self,
    alloc: A
) -&gt; <a class="enum" href="../../../../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Similar to <code>ascend</code>, gets a reference to a node’s parent node, but also
deallocates the current node in the process. This is unsafe because the
current node will still be accessible despite being deallocated.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#417-451">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.reborrow_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#428-430">source</a><h4 class="code-header">unsafe fn <a href="#method.reborrow_mut" class="fn">reborrow_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'_&gt;, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Temporarily takes out another mutable reference to the same node. Beware, as
this method is very dangerous, doubly so since it might not immediately appear
dangerous.</p>
<p>Because mutable pointers can roam anywhere around the tree, the returned
pointer can easily be used to make the original pointer dangling, out of
bounds, or invalid under stacked borrow rules.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_leaf_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#433-437">source</a><h4 class="code-header">fn <a href="#method.as_leaf_mut" class="fn">as_leaf_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Borrows exclusive access to the leaf portion of a leaf or internal node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_leaf_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#440-444">source</a><h4 class="code-header">fn <a href="#method.into_leaf_mut" class="fn">into_leaf_mut</a>(self) -&gt; &amp;'a mut <a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Offers exclusive access to the leaf portion of a leaf or internal node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dormant" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#448-450">source</a><h4 class="code-header">pub fn <a href="#method.dormant" class="fn">dormant</a>(&amp;self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.DormantMut.html" title="enum alloc::collections::btree::node::marker::DormantMut">DormantMut</a>, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Returns a dormant copy of this node with its lifetime erased which can
be reawakened later.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CDormantMut,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#453-463">source</a><a href="#impl-NodeRef%3CDormantMut,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.DormantMut.html" title="enum alloc::collections::btree::node::marker::DormantMut">DormantMut</a>, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.awaken" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#460-462">source</a><h4 class="code-header">pub unsafe fn <a href="#method.awaken" class="fn">awaken</a>&lt;'a&gt;(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Revert to the unique borrow initially captured.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>The reborrow must have ended, i.e., the reference returned by <code>new</code> and
all pointers and references derived from it, must not be used anymore.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CDying,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#465-472">source</a><a href="#impl-NodeRef%3CDying,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_leaf_dying" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#467-471">source</a><h4 class="code-header">fn <a href="#method.as_leaf_dying" class="fn">as_leaf_dying</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Borrows exclusive access to the leaf portion of a dying leaf or internal node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#474-502">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.key_area_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#479-487">source</a><h4 class="code-header">unsafe fn <a href="#method.key_area_mut" class="fn">key_area_mut</a>&lt;I, Output: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;mut self, index: I) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="../../../slice/trait.SliceIndex.html" title="trait alloc::slice::SliceIndex">SliceIndex</a>&lt;[<a class="union" href="../../../../core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;K&gt;], Output = Output&gt;,</span></h4></section></summary><div class="docblock"><p>Borrows exclusive access to an element of the key storage area.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p><code>index</code> is in bounds of 0..CAPACITY</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.val_area_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#493-501">source</a><h4 class="code-header">unsafe fn <a href="#method.val_area_mut" class="fn">val_area_mut</a>&lt;I, Output: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;mut self, index: I) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="../../../slice/trait.SliceIndex.html" title="trait alloc::slice::SliceIndex">SliceIndex</a>&lt;[<a class="union" href="../../../../core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;V&gt;], Output = Output&gt;,</span></h4></section></summary><div class="docblock"><p>Borrows exclusive access to an element or slice of the node’s value storage area.</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p><code>index</code> is in bounds of 0..CAPACITY</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-1" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#504-518">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.edge_area_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#509-517">source</a><h4 class="code-header">unsafe fn <a href="#method.edge_area_mut" class="fn">edge_area_mut</a>&lt;I, Output: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;mut self, index: I) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="../../../slice/trait.SliceIndex.html" title="trait alloc::slice::SliceIndex">SliceIndex</a>&lt;[<a class="union" href="../../../../core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;<a class="struct" href="../../../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="struct" href="struct.LeafNode.html" title="struct alloc::collections::btree::node::LeafNode">LeafNode</a>&lt;K, V&gt;&gt;&gt;], Output = Output&gt;,</span></h4></section></summary><div class="docblock"><p>Borrows exclusive access to an element or slice of the node’s storage area for edge contents.</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p><code>index</code> is in bounds of 0..CAPACITY + 1</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CValMut%3C'a%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#520-537">source</a><a href="#impl-NodeRef%3CValMut%3C'a%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_key_val_mut_at" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#523-536">source</a><h4 class="code-header">unsafe fn <a href="#method.into_key_val_mut_at" class="fn">into_key_val_mut_at</a>(self, idx: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'a K</a>, <a class="primitive" href="../../../../core/primitive.reference.html">&amp;'a mut V</a>)</h4></section></summary><div class="docblock"><h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<ul>
<li>The node has more than <code>idx</code> initialized elements.</li>
</ul>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#539-544">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Type%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#541-543">source</a><h4 class="code-header">pub fn <a href="#method.len_mut" class="fn">len_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../../../core/primitive.u16.html">u16</a></h4></section></summary><div class="docblock"><p>Borrows exclusive access to the length of the node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#546-560">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.correct_childrens_parent_links" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#549-554">source</a><h4 class="code-header">unsafe fn <a href="#method.correct_childrens_parent_links" class="fn">correct_childrens_parent_links</a>&lt;R: <a class="trait" href="../../../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>&gt;&gt;(
    &amp;mut self,
    range: R
)</h4></section></summary><div class="docblock"><h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p>Every item returned by <code>range</code> is a valid edge index for the node.</p>
</div></details><section id="method.correct_all_childrens_parent_links" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#556-559">source</a><h4 class="code-header">fn <a href="#method.correct_all_childrens_parent_links" class="fn">correct_all_childrens_parent_links</a>(&amp;mut self)</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#562-570">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set_parent_link" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#565-569">source</a><h4 class="code-header">fn <a href="#method.set_parent_link" class="fn">set_parent_link</a>(
    &amp;mut self,
    parent: <a class="struct" href="../../../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="struct" href="struct.InternalNode.html" title="struct alloc::collections::btree::node::InternalNode">InternalNode</a>&lt;K, V&gt;&gt;,
    parent_idx: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>
)</h4></section></summary><div class="docblock"><p>Sets the node’s link to its parent edge,
without invalidating other references to the node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#572-579">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clear_parent_link" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#574-578">source</a><h4 class="code-header">fn <a href="#method.clear_parent_link" class="fn">clear_parent_link</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears the root’s link to its parent edge.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-3" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#581-627">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#583-585">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(alloc: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns a new owned tree, with its own root node that is initially empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_internal_level" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#590-598">source</a><h4 class="code-header">pub fn <a href="#method.push_internal_level" class="fn">push_internal_level</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    &amp;mut self,
    alloc: A
) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'_&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a new internal node with a single edge pointing to the previous root node,
make that new node the root node, and return it. This increases the height by 1
and is the opposite of <code>pop_internal_level</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_internal_level" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#609-626">source</a><h4 class="code-header">pub fn <a href="#method.pop_internal_level" class="fn">pop_internal_level</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(&amp;mut self, alloc: A)</h4></section></summary><div class="docblock"><p>Removes the internal root node, using its first child as the new root node.
As it is intended only to be called when the root node has only one child,
no cleanup is done on any of the keys, values and other children.
This decreases the height by 1 and is the opposite of <code>push_internal_level</code>.</p>
<p>Requires exclusive access to the <code>NodeRef</code> object but not to the root node;
it will not invalidate other handles or references to the root node.</p>
<p>Panics if there is no internal level, i.e., if the root node is a leaf.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#629-647">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#633-635">source</a><h4 class="code-header">pub fn <a href="#method.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'_&gt;, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Mutably borrows the owned root node. Unlike <code>reborrow_mut</code>, this is safe
because the return value cannot be used to destroy the root, and there
cannot be other references to the tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.borrow_valmut" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#638-640">source</a><h4 class="code-header">pub fn <a href="#method.borrow_valmut" class="fn">borrow_valmut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'_&gt;, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Slightly mutably borrows the owned root node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_dying" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#644-646">source</a><h4 class="code-header">pub fn <a href="#method.into_dying" class="fn">into_dying</a>(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, Type&gt;</h4></section></summary><div class="docblock"><p>Irreversibly transitions to a reference that permits traversal and offers
destructive methods and little else.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Leaf%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#649-662">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Leaf%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#652-661">source</a><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, key: K, val: V) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut V</a></h4></section></summary><div class="docblock"><p>Adds a key-value pair to the end of the node, and returns
the mutable reference of the inserted value.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-3" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#664-681">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+Internal%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.push-1" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#667-680">source</a><h4 class="code-header">pub fn <a href="#method.push-1" class="fn">push</a>(
    &amp;mut self,
    key: K,
    val: V,
    edge: <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;
)</h4></section></summary><div class="docblock"><p>Adds a key-value pair, and an edge to go to the right of that pair,
to the end of the node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Leaf%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#683-688">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Leaf%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.forget_type" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#685-687">source</a><h4 class="code-header">pub fn <a href="#method.forget_type" class="fn">forget_type</a>(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h4></section></summary><div class="docblock"><p>Removes any static information asserting that this node is a <code>Leaf</code> node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E-2" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#690-695">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Internal%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.forget_type-1" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#692-694">source</a><h4 class="code-header">pub fn <a href="#method.forget_type-1" class="fn">forget_type</a>(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h4></section></summary><div class="docblock"><p>Removes any static information asserting that this node is an <code>Internal</code> node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-3" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#697-719">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.force" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#699-718">source</a><h4 class="code-header">pub fn <a href="#method.force" class="fn">force</a>(
    self
) -&gt; <a class="enum" href="enum.ForceResult.html" title="enum alloc::collections::btree::node::ForceResult">ForceResult</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Checks whether a node is an <code>Internal</code> node or a <code>Leaf</code> node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-3" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#721-733">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_to_leaf_unchecked" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#723-726">source</a><h4 class="code-header">unsafe fn <a href="#method.cast_to_leaf_unchecked" class="fn">cast_to_leaf_unchecked</a>(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;</h4></section></summary><div class="docblock"><p>Unsafely asserts to the compiler the static information that this node is a <code>Leaf</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast_to_internal_unchecked" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#729-732">source</a><h4 class="code-header">unsafe fn <a href="#method.cast_to_internal_unchecked" class="fn">cast_to_internal_unchecked</a>(self) -&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.Internal.html" title="enum alloc::collections::btree::node::marker::Internal">Internal</a>&gt;</h4></section></summary><div class="docblock"><p>Unsafely asserts to the compiler the static information that this node is an <code>Internal</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-4" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#1275-1310">source</a><a href="#impl-NodeRef%3CMut%3C'a%3E,+K,+V,+LeafOrInternal%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'a&gt;, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.choose_parent_kv" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#1290-1309">source</a><h4 class="code-header">pub fn <a href="#method.choose_parent_kv" class="fn">choose_parent_kv</a>(
    self
) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="enum.LeftOrRight.html" title="enum alloc::collections::btree::node::LeftOrRight">LeftOrRight</a>&lt;<a class="struct" href="struct.BalancingContext.html" title="struct alloc::collections::btree::node::BalancingContext">BalancingContext</a>&lt;'a, K, V&gt;&gt;, Self&gt;</h4></section></summary><div class="docblock"><p>Chooses a balancing context involving the node as a child, thus between
the KV immediately to the left or to the right in the parent node.
Returns an <code>Err</code> if there is no parent.
Panics if the parent is empty.</p>
<p>Prefers the left side, to be optimal if the given node is somehow
underfull, meaning here only that it has fewer elements than its left
sibling and than its right sibling, if they exist. In that case,
merging with the left sibling is faster, since we only need to move
the node’s N elements, instead of shifting them to the right and moving
more than N elements in front. Stealing from the left sibling is also
typically faster, since we only need to shift the node’s N elements to
the right, instead of shifting at least N of the sibling’s elements to
the left.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-4" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#41-184">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+LeafOrInternal%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType: <a class="trait" href="marker/trait.BorrowType.html" title="trait alloc::collections::btree::node::marker::BorrowType">BorrowType</a>, K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.search_tree" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#48-65">source</a><h4 class="code-header">pub fn <a href="#method.search_tree" class="fn">search_tree</a>&lt;Q&gt;(
    self,
    key: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>
) -&gt; <a class="enum" href="../search/enum.SearchResult.html" title="enum alloc::collections::btree::search::SearchResult">SearchResult</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Looks up a given key in a (sub)tree headed by the node, recursively.
Returns a <code>Found</code> with the handle of the matching KV, if any. Otherwise,
returns a <code>GoDown</code> with the handle of the leaf edge where the key belongs.</p>
<p>The result is meaningful only if the tree is ordered by key, like the tree
in a <code>BTreeMap</code> is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.search_tree_for_bifurcation" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#82-151">source</a><h4 class="code-header">pub fn <a href="#method.search_tree_for_bifurcation" class="fn">search_tree_for_bifurcation</a>&lt;'r, Q, R&gt;(
    self,
    range: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r R</a>
) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;, <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;), <a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, <a class="enum" href="marker/enum.Leaf.html" title="enum alloc::collections::btree::node::marker::Leaf">Leaf</a>&gt;, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    R: <a class="trait" href="../../../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Descends to the nearest node where the edge matching the lower bound
of the range is different from the edge matching the upper bound, i.e.,
the nearest node that has at least one key contained in the range.</p>
<p>If found, returns an <code>Ok</code> with that node, the strictly ascending pair of
edge indices in the node delimiting the range, and the corresponding
pair of bounds for continuing the search in the child nodes, in case
the node is internal.</p>
<p>If not found, returns an <code>Err</code> with the leaf edge matching the entire
range.</p>
<p>As a diagnostic service, panics if the range specifies impossible bounds.</p>
<p>The result is meaningful only if the tree is ordered by key.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_lower_bound_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#158-169">source</a><h4 class="code-header">pub fn <a href="#method.find_lower_bound_edge" class="fn">find_lower_bound_edge</a>&lt;'r, Q&gt;(
    self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;
) -&gt; (<a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;)<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Finds an edge in the node delimiting the lower bound of a range.
Also returns the lower bound to be used for continuing the search in
the matching child node, if <code>self</code> is an internal node.</p>
<p>The result is meaningful only if the tree is ordered by key.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_upper_bound_edge" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#172-183">source</a><h4 class="code-header">pub fn <a href="#method.find_upper_bound_edge" class="fn">find_upper_bound_edge</a>&lt;'r, Q&gt;(
    self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;
) -&gt; (<a class="struct" href="struct.Handle.html" title="struct alloc::collections::btree::node::Handle">Handle</a>&lt;Self, <a class="enum" href="marker/enum.Edge.html" title="enum alloc::collections::btree::node::marker::Edge">Edge</a>&gt;, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;)<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Clone of <code>find_lower_bound_edge</code> for the upper bound.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-3" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#186-285">source</a><a href="#impl-NodeRef%3CBorrowType,+K,+V,+Type%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.search_node" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#194-203">source</a><h4 class="code-header">pub fn <a href="#method.search_node" class="fn">search_node</a>&lt;Q&gt;(
    self,
    key: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>
) -&gt; <a class="enum" href="../search/enum.SearchResult.html" title="enum alloc::collections::btree::search::SearchResult">SearchResult</a>&lt;BorrowType, K, V, Type, Type&gt;<span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Looks up a given key in the node, without recursion.
Returns a <code>Found</code> with the handle of the matching KV, if any. Otherwise,
returns a <code>GoDown</code> with the handle of the edge where the key might be found
(if the node is internal) or where the key can be inserted.</p>
<p>The result is meaningful only if the tree is ordered by key, like the tree
in a <code>BTreeMap</code> is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_key_index" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#213-229">source</a><h4 class="code-header">unsafe fn <a href="#method.find_key_index" class="fn">find_key_index</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>, start_index: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../search/enum.IndexResult.html" title="enum alloc::collections::btree::search::IndexResult">IndexResult</a><span class="where fmt-newline">where
    Q: <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Returns either the KV index in the node at which the key (or an equivalent)
exists, or the edge index where the key belongs, starting from a particular index.</p>
<p>The result is meaningful only if the tree is ordered by key, like the tree
in a <code>BTreeMap</code> is.</p>
<h5 id="safety-9"><a href="#safety-9">Safety</a></h5>
<p><code>start_index</code> must be a valid edge index for the node.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_lower_bound_index" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#236-256">source</a><h4 class="code-header">fn <a href="#method.find_lower_bound_index" class="fn">find_lower_bound_index</a>&lt;'r, Q&gt;(
    &amp;self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;
) -&gt; (<a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;)<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Finds an edge index in the node delimiting the lower bound of a range.
Also returns the lower bound to be used for continuing the search in
the matching child node, if <code>self</code> is an internal node.</p>
<p>The result is meaningful only if the tree is ordered by key.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_upper_bound_index" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/search.rs.html#263-284">source</a><h4 class="code-header">unsafe fn <a href="#method.find_upper_bound_index" class="fn">find_upper_bound_index</a>&lt;'r, Q&gt;(
    &amp;self,
    bound: <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;,
    start_index: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>
) -&gt; (<a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, <a class="enum" href="../search/enum.SearchBound.html" title="enum alloc::collections::btree::search::SearchBound">SearchBound</a>&lt;<a class="primitive" href="../../../../core/primitive.reference.html">&amp;'r Q</a>&gt;)<span class="where fmt-newline">where
    Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Mirror image of <code>find_lower_bound_index</code> for the upper bound,
with an additional parameter to skip part of the key array.</p>
<h5 id="safety-10"><a href="#safety-10">Safety</a></h5>
<p><code>start_index</code> must be a valid edge index for the node.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-4" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/split.rs.html#6-73">source</a><a href="#impl-NodeRef%3COwned,+K,+V,+LeafOrInternal%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.calc_split_length" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/split.rs.html#9-25">source</a><h4 class="code-header">pub fn <a href="#method.calc_split_length" class="fn">calc_split_length</a>(
    total_num: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>,
    root_a: &amp;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;,
    root_b: &amp;<a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, <a class="enum" href="marker/enum.LeafOrInternal.html" title="enum alloc::collections::btree::node::marker::LeafOrInternal">LeafOrInternal</a>&gt;
) -&gt; (<a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Calculates the length of both trees that result from splitting up
a given number of distinct key-value pairs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_off" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/split.rs.html#32-63">source</a><h4 class="code-header">pub fn <a href="#method.split_off" class="fn">split_off</a>&lt;Q: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>, A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    &amp;mut self,
    key: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Q</a>,
    alloc: A
) -&gt; Self<span class="where fmt-newline">where
    K: <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;Q&gt;,</span></h4></section></summary><div class="docblock"><p>Split off a tree with key-value pairs at and after the given key.
The result is meaningful only if the tree is ordered by key,
and if the ordering of <code>Q</code> corresponds to that of <code>K</code>.
If <code>self</code> respects all <code>BTreeMap</code> tree invariants, then both
<code>self</code> and the returned tree will respect those invariants.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_pillar" class="method"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/split.rs.html#66-72">source</a><h4 class="code-header">fn <a href="#method.new_pillar" class="fn">new_pillar</a>&lt;A: <a class="trait" href="../../../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(height: <a class="primitive" href="../../../../core/primitive.usize.html">usize</a>, alloc: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a tree consisting of empty nodes.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#201-205">source</a><a href="#impl-Clone-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a, Type&gt; <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#202-204">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="../../../../core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../../../src/core/clone.rs.html#129">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="../../../../core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><section id="impl-Copy-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#200">source</a><a href="#impl-Copy-for-NodeRef%3CImmut%3C'a%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: 'a, V: 'a, Type&gt; <a class="trait" href="../../../../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'a&gt;, K, V, Type&gt;</h3></section><section id="impl-Send-for-NodeRef%3CDying,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#213">source</a><a href="#impl-Send-for-NodeRef%3CDying,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, V: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Dying.html" title="enum alloc::collections::btree::node::marker::Dying">Dying</a>, K, V, Type&gt;</h3></section><section id="impl-Send-for-NodeRef%3CImmut%3C'_%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#209">source</a><a href="#impl-Send-for-NodeRef%3CImmut%3C'_%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: <a class="trait" href="../../../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>, V: <a class="trait" href="../../../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Immut.html" title="struct alloc::collections::btree::node::marker::Immut">Immut</a>&lt;'_&gt;, K, V, Type&gt;</h3></section><section id="impl-Send-for-NodeRef%3CMut%3C'_%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#210">source</a><a href="#impl-Send-for-NodeRef%3CMut%3C'_%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, V: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.Mut.html" title="struct alloc::collections::btree::node::marker::Mut">Mut</a>&lt;'_&gt;, K, V, Type&gt;</h3></section><section id="impl-Send-for-NodeRef%3COwned,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#212">source</a><a href="#impl-Send-for-NodeRef%3COwned,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, V: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="enum" href="marker/enum.Owned.html" title="enum alloc::collections::btree::node::marker::Owned">Owned</a>, K, V, Type&gt;</h3></section><section id="impl-Send-for-NodeRef%3CValMut%3C'_%3E,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#211">source</a><a href="#impl-Send-for-NodeRef%3CValMut%3C'_%3E,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, V: <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;<a class="struct" href="marker/struct.ValMut.html" title="struct alloc::collections::btree::node::marker::ValMut">ValMut</a>&lt;'_&gt;, K, V, Type&gt;</h3></section><section id="impl-Sync-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/collections/btree/node.rs.html#207">source</a><a href="#impl-Sync-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K: <a class="trait" href="../../../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>, V: <a class="trait" href="../../../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>, Type&gt; <a class="trait" href="../../../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a href="#impl-RefUnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;<span class="where fmt-newline">where
    BorrowType: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    K: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    Type: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    V: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a href="#impl-Send-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; !<a class="trait" href="../../../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;</h3></section><section id="impl-Unpin-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a href="#impl-Unpin-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="trait" href="../../../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;<span class="where fmt-newline">where
    BorrowType: <a class="trait" href="../../../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Type: <a class="trait" href="../../../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a href="#impl-UnwindSafe-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;BorrowType, K, V, Type&gt; <a class="trait" href="../../../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.NodeRef.html" title="struct alloc::collections::btree::node::NodeRef">NodeRef</a>&lt;BorrowType, K, V, Type&gt;<span class="where fmt-newline">where
    BorrowType: <a class="trait" href="../../../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    K: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    Type: <a class="trait" href="../../../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    V: <a class="trait" href="../../../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/any.rs.html#200">source</a><a href="#impl-Any-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../../core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../../../core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../../../core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../borrow/trait.BorrowMut.html" title="trait alloc::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../../../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#725">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/borrow.rs.html#82-94">source</a><a href="#impl-ToOwned-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="../../../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="../../../borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="../../../../src/alloc/borrow.rs.html#87-89">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="../../../borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="../../../../src/alloc/borrow.rs.html#91-93">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="../../../../core/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="../../../borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../../../../core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../../core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../../core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../../../../core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-NonDrop-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="impl"><a class="srclink rightside" href="../../../../src/alloc/vec/into_iter.rs.html#371">source</a><a href="#impl-NonDrop-for-NodeRef%3CBorrowType,+K,+V,+Type%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../vec/into_iter/trait.NonDrop.html" title="trait alloc::vec::into_iter::NonDrop">NonDrop</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="../../../../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,</span></h3></section></div></section></div></main></body></html>