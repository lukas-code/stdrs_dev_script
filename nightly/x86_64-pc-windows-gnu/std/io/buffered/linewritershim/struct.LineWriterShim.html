<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Private helper struct for implementing the line-buffered writing logic. This shim temporarily wraps a BufWriter, and uses its internals to implement a line-buffered writer (specifically by using the internal methods like write_to_buf and flush_buf). In this way, a more efficient abstraction can be created than one that only had access to `write` and `flush`, without needlessly duplicating a lot of the implementation details of BufWriter. This also allows existing `BufWriters` to be temporarily given line-buffering logic; this is what enables Stdout to be alternately in line-buffered or block-buffered mode."><title>LineWriterShim in std::io::buffered::linewritershim - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (b2b34bd83 2023-06-06)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-48600a9606eff342.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"><script src="/stdrs_dev_script/nav.js"></script>
</head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">LineWriterShim</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.buffer">buffer</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.buffered">buffered</a></li><li><a href="#method.flush_if_completed_line">flush_if_completed_line</a></li><li><a href="#method.inner">inner</a></li><li><a href="#method.inner_mut">inner_mut</a></li><li><a href="#method.new">new</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-LineWriterShim%3C'a,+W%3E">Debug</a></li><li><a href="#impl-Write-for-LineWriterShim%3C'a,+W%3E">Write</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-UnwindSafe-for-LineWriterShim%3C'a,+W%3E">!UnwindSafe</a></li><li><a href="#impl-RefUnwindSafe-for-LineWriterShim%3C'a,+W%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-LineWriterShim%3C'a,+W%3E">Send</a></li><li><a href="#impl-Sync-for-LineWriterShim%3C'a,+W%3E">Sync</a></li><li><a href="#impl-Unpin-for-LineWriterShim%3C'a,+W%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-LineWriterShim%3C'a,+W%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-LineWriterShim%3C'a,+W%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-LineWriterShim%3C'a,+W%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-LineWriterShim%3C'a,+W%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-LineWriterShim%3C'a,+W%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-LineWriterShim%3C'a,+W%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-LineWriterShim%3C'a,+W%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In std::io::buffered::linewritershim</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../../index.html">std</a>::<wbr><a href="../../index.html">io</a>::<wbr><a href="../index.html">buffered</a>::<wbr><a href="index.html">linewritershim</a>::<wbr><a class="struct" href="#">LineWriterShim</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../../src/std/io/buffered/linewritershim.rs.html#14-16">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct LineWriterShim&lt;'a, W: <a class="trait" href="../../trait.Write.html" title="trait std::io::Write">Write</a>&gt; {
    buffer: &amp;'a mut <a class="struct" href="../bufwriter/struct.BufWriter.html" title="struct std::io::buffered::bufwriter::BufWriter">BufWriter</a>&lt;W&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Private helper struct for implementing the line-buffered writing logic.
This shim temporarily wraps a BufWriter, and uses its internals to
implement a line-buffered writer (specifically by using the internal
methods like write_to_buf and flush_buf). In this way, a more
efficient abstraction can be created than one that only had access to
<code>write</code> and <code>flush</code>, without needlessly duplicating a lot of the
implementation details of BufWriter. This also allows existing
<code>BufWriters</code> to be temporarily given line-buffering logic; this is what
enables Stdout to be alternately in line-buffered or block-buffered mode.</p>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.buffer" class="structfield small-section-header"><a href="#structfield.buffer" class="anchor field">§</a><code>buffer: &amp;'a mut <a class="struct" href="../bufwriter/struct.BufWriter.html" title="struct std::io::buffered::bufwriter::BufWriter">BufWriter</a>&lt;W&gt;</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#18-50">source</a><a href="#impl-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W: <a class="trait" href="../../trait.Write.html" title="trait std::io::Write">Write</a>&gt; <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;</h3></section></summary><div class="impl-items"><section id="method.new" class="method"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#19-21">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(buffer: &amp;'a mut <a class="struct" href="../bufwriter/struct.BufWriter.html" title="struct std::io::buffered::bufwriter::BufWriter">BufWriter</a>&lt;W&gt;) -&gt; Self</h4></section><details class="toggle method-toggle" open><summary><section id="method.inner" class="method"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#25-27">source</a><h4 class="code-header">fn <a href="#method.inner" class="fn">inner</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.reference.html">&amp;W</a></h4></section></summary><div class="docblock"><p>Get a reference to the inner writer (that is, the writer
wrapped by the BufWriter).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inner_mut" class="method"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#32-34">source</a><h4 class="code-header">fn <a href="#method.inner_mut" class="fn">inner_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../../primitive.reference.html">&amp;mut W</a></h4></section></summary><div class="docblock"><p>Get a mutable reference to the inner writer (that is, the writer
wrapped by the BufWriter). Be careful with this writer, as writes to
it will bypass the buffer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.buffered" class="method"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#37-39">source</a><h4 class="code-header">fn <a href="#method.buffered" class="fn">buffered</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="../../../primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Get the content currently buffered in self.buffer</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush_if_completed_line" class="method"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#44-49">source</a><h4 class="code-header">fn <a href="#method.flush_if_completed_line" class="fn">flush_if_completed_line</a>(&amp;mut self) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Flush the buffer iff the last byte is a newline (indicating that an
earlier write only succeeded partially, and we want to retry flushing
the buffered line before continuing with a subsequent write)</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#13">source</a><a href="#impl-Debug-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W: <a class="trait" href="../../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> + <a class="trait" href="../../trait.Write.html" title="trait std::io::Write">Write</a>&gt; <a class="trait" href="../../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#13">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../../../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../../../fmt/type.Result.html" title="type std::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Write-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#52-276">source</a><a href="#impl-Write-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W: <a class="trait" href="../../trait.Write.html" title="trait std::io::Write">Write</a>&gt; <a class="trait" href="../../trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#66-133">source</a><a href="#method.write" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#tymethod.write" class="fn">write</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="../../../primitive.u8.html">u8</a>]) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Write some data into this BufReader with line buffering. This means
that, if any newlines are present in the data, the data up to the last
newline is sent directly to the underlying writer, and data after it
is buffered. Returns the number of bytes written.</p>
<p>This function operates on a “best effort basis”; in keeping with the
convention of <code>Write::write</code>, it makes at most one attempt to write
new data to the underlying writer. If that write only reports a partial
success, the remaining data will be buffered.</p>
<p>Because this function attempts to send completed lines to the underlying
writer, it will also flush the existing buffer if it ends with a
newline, even if the incoming data does not contain any newlines.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_vectored" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#167-233">source</a><a href="#method.write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.write_vectored" class="fn">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class="struct" href="../../struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Write some vectored data into this BufReader with line buffering. This
means that, if any newlines are present in the data, the data up to
and including the buffer containing the last newline is sent directly
to the inner writer, and the data after it is buffered. Returns the
number of bytes written.</p>
<p>This function operates on a “best effort basis”; in keeping with the
convention of <code>Write::write</code>, it makes at most one attempt to write
new data to the underlying writer.</p>
<p>Because this function attempts to send completed lines to the underlying
writer, it will also flush the existing buffer if it contains any
newlines.</p>
<p>Because sorting through an array of <code>IoSlice</code> can be a bit convoluted,
This method differs from write in the following ways:</p>
<ul>
<li>It attempts to write the full content of all the buffers up to and
including the one containing the last newline. This means that it
may attempt to write a partial line, that buffer has data past the
newline.</li>
<li>If the write only reports partial success, it does not attempt to
find the precise location of the written bytes and buffer the rest.</li>
</ul>
<p>If the underlying vector doesn’t support vectored writing, we instead
simply write the first non-empty buffer with <code>write</code>. This way, we
get the benefits of more granular partial-line handling without losing
anything in efficiency</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_all" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#247-275">source</a><a href="#method.write_all" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.write_all" class="fn">write_all</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="../../../primitive.u8.html">u8</a>]) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Write some data into this BufReader with line buffering. This means
that, if any newlines are present in the data, the data up to the last
newline is sent directly to the underlying writer, and data after it
is buffered.</p>
<p>Because this function attempts to send completed lines to the underlying
writer, it will also flush the existing buffer if it contains any
newlines, even if the incoming data does not contain any newlines.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#135-137">source</a><a href="#method.flush" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#tymethod.flush" class="fn">flush</a>(&amp;mut self) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit.html">()</a>&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination. <a href="../../trait.Write.html#tymethod.flush">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_write_vectored" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/buffered/linewritershim.rs.html#235-237">source</a><a href="#method.is_write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.is_write_vectored" class="fn">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/69941">#69941</a>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href="../../trait.Write.html#method.write_vectored" title="method std::io::Write::write_vectored"><code>write_vectored</code></a>
implementation. <a href="../../trait.Write.html#method.is_write_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_all_vectored" class="method trait-impl"><a class="srclink rightside" href="../../../../src/std/io/mod.rs.html#1636-1654">source</a><a href="#method.write_all_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.write_all_vectored" class="fn">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="../../struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit.html">()</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/70436">#70436</a>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a href="../../trait.Write.html#method.write_all_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_fmt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../../../src/std/io/mod.rs.html#1692-1724">source</a></span><a href="#method.write_fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.write_fmt" class="fn">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="../../../fmt/struct.Arguments.html" title="struct std::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="type" href="../../error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit.html">()</a>&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error
encountered. <a href="../../trait.Write.html#method.write_fmt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../../../src/std/io/mod.rs.html#1748-1753">source</a></span><a href="#method.by_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../trait.Write.html#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../../../primitive.reference.html">&amp;mut Self</a><span class="where fmt-newline">where
    Self: <a class="trait" href="../../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="../../trait.Write.html#method.by_ref">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-LineWriterShim%3C'a,+W%3E" class="impl"><a href="#impl-RefUnwindSafe-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W&gt; <a class="trait" href="../../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;<span class="where fmt-newline">where
    W: <a class="trait" href="../../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-LineWriterShim%3C'a,+W%3E" class="impl"><a href="#impl-Send-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W&gt; <a class="trait" href="../../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;<span class="where fmt-newline">where
    W: <a class="trait" href="../../../marker/trait.Send.html" title="trait std::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-LineWriterShim%3C'a,+W%3E" class="impl"><a href="#impl-Sync-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W&gt; <a class="trait" href="../../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;<span class="where fmt-newline">where
    W: <a class="trait" href="../../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-LineWriterShim%3C'a,+W%3E" class="impl"><a href="#impl-Unpin-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W&gt; <a class="trait" href="../../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;</h3></section><section id="impl-UnwindSafe-for-LineWriterShim%3C'a,+W%3E" class="impl"><a href="#impl-UnwindSafe-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, W&gt; !<a class="trait" href="../../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.LineWriterShim.html" title="struct std::io::buffered::linewritershim::LineWriterShim">LineWriterShim</a>&lt;'a, W&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/any.rs.html#200">source</a><a href="#impl-Any-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../any/trait.Any.html" title="trait std::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="../../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../../../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#725">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../../../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-LineWriterShim%3C'a,+W%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../../../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="../../../../src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"../../trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]</span>"}</script></section></div></main></body></html>